%% Background
\chapter{Background}\label{sec:background}
\section{Classical Processes}\label{sec:cp}
In this section, we will discuss a rudimentary subset of the typed process
calculus \cp~\cite{wadler2012}, which we will refer to as \rcp.
We have chosen to discuss only a subset in order to keep our later discussion of
our extension to \cp in \cref{sec:main} as simple as possible.
However, we foresee no problems in extending the proofs from \cref{sec:main} to
cover the full version of \cp.
\rcp corresponds to rudimentary linear logic~\cite[RLL]{girard1992}, which is
also known as multiplicative-applicative linear logic.

This section will proceed as follows. First, we will discuss the terms, the
structural congruence, and the types of \rcp.
Then we will discuss the terms and their corresponding types, in small groups,
together with their typing and reduction rules.
Finally, we will prove preservation, progress and termination for \rcp.

\subsection{Terms and types}\label{sec:cp:terms-and-types}
The term language for \rcp is a variant of the
\textpi-calculus~\cite{milner1992b}.
Its terms are defined by the following grammar:
\input{def-cp-terms}
The construct \tm{\cpLink{x}{y}} links two
channels~\cite{sangiorgi1996,boreale1998}, forwarding messages received on
\tm{x} to \tm{y} and vice versa.
The construct \tm{\cpCut{x}{P}{Q}} creates a new channel \tm{x}, and composes
two processes, \tm{P} and \tm{Q}, which communicate on \tm{x}, in parallel.
Therefore, in \tm{\cpCut{x}{P}{Q}} the name \tm{x} is bound in both \tm{P} and
\tm{Q}.
In \tm{\cpRecv{x}{y}{P}} and \tm{\cpSend{x}{y}{P}{Q}}, round brackets are used
for input, square brackets for output.
We use bound output~\cite{sangiorgi1996}.
This means that unlike in the \textpi-calculus, both input and output bind a new
name.
In \tm{\cpRecv{x}{y}{P}} the new name \tm{y} is bound in \tm{P}.
In \tm{\cpSend{x}{y}{P}{Q}}, the new name \tm{y} is only bound in \tm{P}, while
\tm{x} is only bound in \tm{Q}.

Terms in \rcp are identified up to structural congruence, which states that
parallel compositions \tm{\cpCut{x}{P}{Q}} are associative and commutative.
It is defined as follows:
\input{def-cp-equiv}
We do not add an axiom for \cpEquivCutAss2, as it follows from
\cref{def:cp-equiv}, see~\cref{thm:cp-cut-assoc2}.
Note that throughout this thesis, we will leave uses of the transitivity and
congruence rules implicit.
\input{thm-cp-cut-assoc2}
Furthermore, structural congruence is a symmetric relation.
\input{thm-cp-symmetry}
%
Channels in \rcp are typed using a session type system which corresponds to RLL,
the multiplicative, additive fragment of linear logic.
These are defined using the following grammar:
\input{def-cp-types}
Duality plays a crucial role in both linear logic and session types.
In \cp, the two endpoints of a channel are assigned dual types.
This ensures that, for instance, whenever a process \emph{sends} across a
channel, the process on the other end of that channel is waiting to
\emph{receive}.
Each type \ty{A} has a dual, written \ty{A^\bot}, which is defined as follows:
\input{def-cp-negation}
Duality is an involutive function.
\input{thm-cp-negation-involutive}
%
Environments associate channels with types. They are defined as follows:
\input{def-cp-environments}
Typing judgements associative processes with their collection of channels, and
enforce the communication protocols specified by the types of those channels.
They are defined as follows:
\input{def-cp-typing-judgement}
\input{fig-cp-typing-judgement}
Reductions relate processes with their reduced forms.
They are defined as follows:
\input{def-cp-term-reduction}
\input{fig-cp-term-reduction}
We will discuss the interpretations of each connective, together with their
typing and reduction rules, in
\cref{sec:cp-dependence,sec:cp-choice,sec:cp-duality}.

\subsection{Multiplicatives and in- and interdependence}
\label{sec:cp-dependence}
The multiplicatives ($\ty{\tens}, \ty{\parr}$) deal with independence and
interdependence:
\begin{itemize}
\item
  A channel of type \ty{A \tens B} represents a pair of channels, which
  communicate with two \emph{independent} processes---that is to say, two
  processes who share no channels.
  A process acting on a channel of type \ty{A \tens B} will send one endpoint of
  a fresh channel, and then split into a pair of independent processes.
  One of these processes will be responsible for an interaction of type \ty{A}
  over the fresh channel, while the other process continues to interact as
  \ty{B}.
\item
  A channel of type \ty{A \parr B} represents a pair of interdependent channels,
  which are used within a single process.
  A process acting on a channel of type \ty{A \parr B} will receive a channel to
  act on, and communicate on its channels in whatever order it pleases.
  This means that the usage of one channel can depend on that of
  another---e.g.\ the interaction of type \ty{B} could depend on the result of
  the interaction of type \ty{A}, or vise versa, and if \ty{A} and \ty{B} are
  complex types, their interactions could likewise interweave in complex ways.
\end{itemize}
While the rules for \ty{\tens} and \ty{\parr} introduce input and output
operations, these are inessential---the essential distinction lies two in the
fact that (\tens) composes two independent processes, and therefore \emph{must}
split the environment between them, whereas (\parr) uses a single process, which
then can---and must---use all the channels in the environment.
\begin{center}
  \cpInfTens
  \cpInfParr
\end{center}
The \textbeta-reduction rule for terms introduced by $(\tens)$ and $(\parr)$
implements the behaviour outlined above:
\[
  \tm{\cpCut{x}{\cpSend{x}{y}{P}{Q}}{\cpRecv{x}{z}{R}}}
  \Longrightarrow
  \tm{\cpCut{y}{P}{\cpCut{x}{Q}{\cpSub{y}{z}{R}}}}
\]
%
The rules for the multiplicative units ($\ty{\one}, \ty{\bot}$) follow the same
pattern, except for the nullary instead of the binary case:
\begin{itemize}
\item
  A term constructed by $(\one)$ must composes \emph{zero} independent
  processes, and thus must halt. Furthermore, it must be able to split its
  environment between zero processes, and thus its environment must be empty.
\item
  A term constructed by $(\bot)$, on the other hand, uses a single process,
  which is not further restricted.
\end{itemize}
Note that the rules for $\ty{\one}$ and $\ty{\bot}$ introduce a nullary send and
receive operation, such as those found in the polyadic \textpi-calculus.
\begin{center}
  \cpInfOne
  \cpInfBot
\end{center}
The \textbeta-reduction rule for terms introduced by $(\one)$ and $(\bot)$
implements the behaviour outlined above:
\[
  \tm{\cpCut{x}{\cpHalt{x}}{\cpWait{x}{P}}}
  \Longrightarrow
  \tm{P}
\]

\subsection{Additives and choice}\label{sec:cp-choice}
The additives ($\ty{\plus}, \ty{\with}$) deal with choice:
\begin{itemize}
\item
  A process acting on a channel of type \ty{A \plus B} either sends the value
  \tm{inl} to select an interaction of type \ty{A} or the value \tm{inr} to
  select one of type \ty{B}.
\item
  A process acting on a channel of type \ty{A \with B} receives such a value,
  and then offers an interaction of either type \ty{A} or \ty{B},
  correspondingly.
\end{itemize}
Note that, in essence, the additive operations implement the sending and
receiving of a single bit of information, \tm{inl} or \tm{inr}, and branching
based on the value of that bit.
The rule for constructing a process which sends \tm{inr}, $(\plus_2)$, has been
omitted, but can be found in~\cref{fig:cp-typing-judgement}.
\begin{center}
  \cpInfPlus1
  \cpInfWith
\end{center}
The \textbeta-reduction rules for terms introduced by $(\plus_1)$, $(\plus_2)$
and $(\with)$ implements the behaviour outlined above.
\[
  \tm{\cpCut{x}{\cpInl{x}{P}}{\cpCase{x}{Q}{R}}}
  \Longrightarrow
  \tm{\cpCut{x}{P}{Q}}
\]
\[
  \tm{\cpCut{x}{\cpInr{x}{P}}{\cpCase{x}{Q}{R}}}
  \Longrightarrow
  \tm{\cpCut{x}{P}{R}}
\]
%
The rules for the additive units ($\ty{\nil}, \ty{\top}$) follow the same
pattern, except for a nullary choice:
\begin{itemize}
\item
  There is \emph{no} rule for \ty{\nil}, as a process acting on a channel of
  that type would have to select one of \emph{zero} options, which is clearly
  impossible.
\item
  A process acting on a channel of type \ty{\top} will wait to receive a choice
  of out \emph{zero} options. Since this will clearly never arrive, we have two
  options: either we block, waiting forever, or we simply crash.
\end{itemize}
It may seem odd at first to include a type for the process which cannot possibly
exist, and for the process which waits forever, but these make sensible units
for choice.
When offered a choice of type \ty{A \plus \nil}, one can either choose to
interact as \ty{A}, or choose to commit to doing the impossible.
Similarly, when offering a choice of type \ty{A \with \top}, one can safely
implement the right branch with a process which waits forever, as no sound
process will ever be able to select that branch anyway.
\begin{center}
  \cpInfNil
  \cpInfTop
\end{center}
As there is no way to construct a process of type \ty{\nil}, there is no
reduction rule for the additive units.


\subsection{Structural rules and duality}\label{sec:cp-duality}
Duality plays a crucial role in session type systems.
In~\cref{sec:cp-choice}, we saw that duality ensures a process offering a choice
is always matched with a process making a choice.
In~\cref{sec:cp-dependence}, we saw that it is also crucial to deadlock freedom,
as it ensures that, for instance, a process which uses communication on \tm{x}
to decide what to send on \tm{y} is matched with a pair of independent processes
on \tm{x} and \tm{y}, preventing circular dependencies.

Duality appears in the typing rules for two \rcp term constructs.
Forwarding, \tm{\cpLink{x}{y}}, connects two dual channels with dual endpoints,
while composition, \tm{\cpCut{x}{P}{Q}}, composes two processes \tm{P} and
\tm{Q} with a shared channel \tm{x}, requiring that they follow dual protocols
on \tm{x}.
\begin{center}
  \cpInfAx
  \cpInfCut
\end{center}
There are two reduction rules which deal with the interactions between
forwarding and compositions. These implement the intuition that if a process is
meant to communicate on \tm{x}, \tm{x} is forwarding to \tm{y}, and nobody else
is listening on \tm{x}, then the process might as well start communicating on
\tm{y}.
\[
  \tm{\cpCut{x}{\cpLink{w}{x}}{P}} \Longrightarrow \tm{\cpSub{w}{x}{P}} 
\]
\[
  \tm{\cpCut{x}{\cpLink{x}{w}}{P}} \Longrightarrow \tm{\cpSub{w}{x}{P}}  
\]
Note that we can do this \emph{solely} because \rcp implements a binary session
type system, meaning that each communication has only two participants, and
therefore we know that no other process is communicating on \tm{x}.


% However, it is worth discussing the commutative conversion for \ty{\top} here,
% separately. In \cp, commutative conversions push compositions,
% \tm{\cpCut{x}{P}{Q}}, deeper into terms, under unrelated actions. However,
% looking at the commutative conversion for \ty{\top} from different
% perspective, we see that it states that if one of the two communication
% partners is blocked forever, we can consider their composition to be blocked
% forever as well: 
% \[\tm{\cpCut{x}{\cpAbsurd{y}}{R}} \Longrightarrow \tm{\cpAbsurd{y}} \]


\subsection{Properties of \rcp}\label{sec:cp-properties}
In this section, we will prove three important properties of \rcp, namely
preservation, progress and termination.

\subsubsection{Preservation}
Preservation is the fact that term reduction preserves typing. In order to prove
this, we will first need to prove that equivalence preserves typing.
\input{thm-cp-preservation-equiv}
\input{fig-cp-preservation-equiv}
Then, we can prove preservation.
\input{thm-cp-preservation}
\input{fig-cp-preservation-1}
\input{fig-cp-preservation-2}

\subsubsection{Progress}
Progress is the fact that every term is either in some canonical form, or can be
reduced further. In order for us to even be able to state progress, we will need
to define when a term is in canonical form.

We have informally used the phrase ``act on'' in previous sections. It is time
to formally define what it means when we say a process \emph{acts on} some
channel.
\input{def-cp-action}

We will need a notion of an \emph{evaluation context}, which
informally is any term under which a reduction can take place. For \rcp, this is
any term consisting solely of cuts:
\input{def-cp-evaluation-contexts}
We define a plugging function for evaluation contexts, which allows us to plug
terms into an evaluation context:
\input{def-cp-evaluation-contexts-plugging}
One important property of evaluation contexts is permutation: we can rearrange
the order of cuts, as long as we do not move any channels outside of the scope
of their cut.
We can prove that we can push any cut downwards under an evaluation contexts, as
long as the channel it binds does not occur in the context itself.
\input{thm-cp-display}
And vice versa. However, we will not use the following lemma in this
dissertation, and leave its proof as an exercise to the reader.
\input{thm-cp-co-display}

\input{def-cp-canonical-forms}
\input{thm-cp-progress}

\subsubsection{Termination}
\input{thm-cp-termination}




%%% Local Variables:
%%% TeX-master: "main"
%%% End:
