%% Background
\chapter{Background}\label{sec:background}
% * Introduction
\section{Related work}
% * - Work on Ï€DILL and CP
\section{Classical Processes}
In this section, we will discuss a rudimentary subset of the typed process calculus \cp~\cite{wadler2012}.
We do this in order to keep the discussion of our extension in \cref{sec:main} as simple as possible.
We will refer to the subset as \rcp, after its corresponding logic, rudimentary linear logic~\cite[RLL]{girard1992}, also known as multiplicative-additive linear logic.
However, as we foresee no problems in extending the proofs given in \cref{sec:main} to the full version of \cp, we will occasionally use \cp where saying \rcp would be more accurate. 

% * Terms
The process calculus used by \rcp is a variant of the \textpi-calculus~\cite{milner1992b}, and its terms are defined by the following grammar:
\input{def-cp-terms}
The construct \tm{\cpLink{x}{y}} links two channels~\cite{sangiorgi1996,boreale1998}, forwarding messages received on \tm{x} to \tm{y} and vice versa.
The construct \tm{\cpCut{x}{P}{Q}} creates a new channel \tm{x}, and composes two processes, \tm{P} and \tm{Q}, which communicate on \tm{x}, in parallel. Therefore, in \tm{\cpCut{x}{P}{Q}} the name \tm{x} is bound in both \tm{P} and \tm{Q}. 
In \tm{\cpRecv{x}{y}{P}} and \tm{\cpSend{x}{y}{P}{Q}}, round brackets are used for input, square brackets for output.
We use bound output~\cite{sangiorgi1996}.
This means that unlike in the \textpi-calculus, both input and output bind a new name. 
In \tm{\cpRecv{x}{y}{P}} the new name \tm{y} is bound in \tm{P}.
In \tm{\cpSend{x}{y}{P}{Q}}, the new name \tm{y} is only bound in \tm{P}, while \tm{x} is only bound in \tm{Q}.

% * Types 
Processes in \rcp are typed using a session type system which corresponds to
RLL, the multiplicative and additive connectives from linear logic.
These are defined using the following grammar:
\input{def-cp-types}
We define the interpretations of each connective below, together with the typing
rules which introduce them.

It is commonplace, in linear logic, to define negation as a function on types,
instead of including it in the grammar.
In this thesis, we follow that practice.
\input{def-cp-negation}
We define our negation such that it is involutive.
\input{thm-cp-negation-involutive}
Environments associate channels with types. They are defined as follows:
\input{def-cp-environments}
Typing judgements associative processes with their collection of channels, and
enforce the communication protocols specified by the types of those channels.
They are defined as follows:
\input{def-cp-typing-judgement}
\input{fig-cp-typing-judgement}
The multiplicatives ($\ty{\tens}, \ty{\parr}$) deal with independence and
interdependence. A channel of type \ty{A \tens B} represents a pair of channels,
which communicate with two \emph{independent} processes---that is to say, two
processes who share no channels. A channel of type \ty{A \parr B} represents a
pair of interdependent channels, which are used within a single process. This
means that their usages can depend on one another---e.g.\ the interaction of
type \ty{B} could depend on the result of the interaction of type \ty{A}, or
vise versa, and if \ty{A} and \ty{B} are complex types, then their interactions
could likewise interweave in complex ways.
While the rules for \ty{\tens} and \ty{\parr} introduce input and output
operations, these are inessential---the essential distinction lies two in the
fact that (\tens) composes two independent processes, and must split the
environment between them, whereas (\parr) uses a single process, which can use
all the channels in the environment.

The rules for the multiplicative units ($\ty{\one}, \ty{\bot}$) follow the same
pattern: (\one) composes \emph{zero} independent processes, and thus must halt;
and (\bot) uses a single process, which is not further restricted.

% * Reduction
Terms in \rcp are identified up to structural congruence, which states that parallel compositions \tm{\cpCut{x}{P}{Q}} are associative and commutative.
It is defined as follows:
\input{def-cp-equiv}
We do not add an axiom for \cpEquivCutAss2, as it follows from \cref{def:cp-equiv}, which we prove below.
Note that, throughout this thesis, we will leave uses of the transitivity and congruence rules implicit.
\input{thm-cp-cut-assoc2}
Furthermore, the structural congruence from \cref{def:cp-equiv} is a symmetric
relation.
\input{thm-cp-symmetry}
\input{def-cp-term-reduction}

% * Preservation 
\input{thm-cp-preservation-equiv}
\input{fig-cp-preservation-equiv}
\input{thm-cp-preservation}
\input{fig-cp-preservation-1}
\input{fig-cp-preservation-2}

% * Progress
\input{def-cp-action}
\input{def-cp-canonical-forms}
\input{def-cp-evaluation-contexts}
\input{def-cp-evaluation-contexts-plugging}
\input{thm-cp-display}
\input{thm-cp-progress}
\input{thm-cp-termination}

%%% Local Variables:
%%% TeX-master: "main"
%%% End:
