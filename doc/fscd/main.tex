\documentclass[a4paper,UKenglish]{lipics-v2016}
\bibliographystyle{plainurl}%
% Author macros::begin
\title{Give or Take: Races in Classical Linear Logic}%
\titlerunning{Give or Take}%
\author[1]{Pepijn Kokke}%
\author[1]{J. Garrett Morris}%
\author[1]{Philip Wadler}%
\affil[1]{LFCS, University of Edinburgh, Edinburgh, United Kingdom\\
  \texttt{\{pepijn.kokke, garrett.morris, philip.wadler\}@ed.ac.uk}}%
\authorrunning{P. Kokke, J. G. Morris, and P. Wadler}%
\Copyright{Pepijn Kokke, J. Garrett Morris, and Philip Wadler}%
\subjclass{
  F.4.1. [Mathematical Logic]: Lambda calculus and related systems;
  D.3.1. [Formal Definitions and Theory]: Syntax;
  D.3.2. [Language Classifications] Concurrent, distributed, and parallel languages
}%
\keywords{$\pi$-calculus, linear logic, session types, deadlock freedom, non-determinism}
% Author macros::end

% Editor-only macros::begin
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important (Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end

% Preamble macros::begin
\input{preamble}
% Preamble macros::end

\begin{document}

\maketitle

\begin{abstract}
  Logically-founded process calculi, such as CP, provide a basis for
  deadlock-free concurrent programming, but at the cost of excluding
  non-determinism and races.  We introduce \nodcap (nodcap), which extends CP
  with a novel account of non-determinism.  Our approach draws on bounded linear
  logic to provide a strongly-typed account of standard process calculus
  expressions of non-determinism.  We show that our extension is expressive
  enough to capture many uses of non-determinism in untyped calculi, such as
  non-deterministic choice, while preserving CP's metatheoretic properties,
  including deadlock freedom.  We have formalized our calculus and its
  properties, using Agda.
\end{abstract}

\section{Introduction}\label{sec:introduction}
Imagine the following scenario:
\begin{quote}
  John and Mary are working from home one morning when they each get a craving
  for a slice of cake. Being denizens of the web, they quickly find a nearby
  p\^atisserie that does home deliveries. Unfortunately for them, they both
  order their cake at the \emph{same} p\^atisserie, which has only one slice
  left. After that, all it can deliver is disappointment.
\end{quote}
This scenario is a classic example of a race condition, and it is modeled in the
$\pi$-calculus by the program below, given that \john, \mary, and \ptis\ are
processes representing John, Mary and the p\^atisserie, respectively, and
\cake\ and \nocake\ are two channels over which \ptis\ will send a slice of
cake, and disappointment, respectively.
The arrows indicate two possible reductions of the program: one in which John
gets the cake and Mary is disappointed, and one in which Mary gets cake and John
is disappointed.
\def\exampleprograma{\red{\ensuremath{%
      \cut{x}(\recv{x}{y}\john \mid \recv{x}{z}\mary \mid
      \send{x}{\cake}\send{x}{\nocake}\ptis)
    }}}
\def\exampleresultaa{\red{\ensuremath{%
      \cut{x}(\subst{\john}{\cake}{y} \mid \subst{\mary}{\nocake}{z} \mid \ptis)
    }}}
\def\exampleresultab{\red{\ensuremath{%
      \cut{x}(\subst{\john}{\nocake}{y} \mid \subst{\mary}{\cake}{z} \mid \ptis)
    }}}
\def\examplereductiona{%
  \begin{tikzpicture}
    \node (program) at (0,0) {$\exampleprograma\quad$};
    \node[above=1cm, right=1cm, at=(program.east)] (resulta)
    {$\!\!^\star\quad\exampleresultaa$};
    \node[below=1cm, right=1cm, at=(program.east)] (resultb)
    {$\!\!^\star\quad\exampleresultab$};
    \draw[->] (program.east) to [out=045,in=180] (resulta.west);
    \draw[->] (program.east) to [out=315,in=180] (resultb.west);
  \end{tikzpicture}
}
\[\examplereductiona\]
Races show up in any client/server system where clients compete for limited
server resources. It is therefore important that any concurrent programming
language allows us to write them.
\\
It should be obvious from the above example that the $\pi$-calculus is up to the
task of modeling such programs. However, it can also model some undesirable
programs, programs which `go wrong'. An example of such a program is the
following scenario:
\begin{quote}
  John managed to order the last slice of cake from the p\^atisserie. However,
  Mary \emph{really} wants it, and offers him some money for it. John agrees,
  but sadly there is no trust between the two. Mary demands to get the cake
  first, before she gives John the money. John demands to get the money first,
  before he gives Mary the cake.
\end{quote}
This scenario is a classic example of a deadlock, and it is modeled in the
$\pi$-calculus by the program below, given that \john\ and \mary\ are processes
representing John and Mary, respectively, \cake\ is a channel over which
\john\ will send a slice of cake, and \dollar\ is a channel over which \mary\ %
will send money.
\def\exampleprogramb{\red{\ensuremath{%
      \cut{x}(\recv{x}{y}\send{x}{\cake}\john \mid \recv{x}{z}\send{x}{\dollar}\mary)
    }}}
\[\exampleprogramb\]
The program is stuck---John is refusing to send the cake until he receives money
from Mary, and Mary is refusing to send the money until John sends the cake, so
nothing will actually happen.
It `goes wrong', in the sense that a deadlock is unlikely to be the intended
behaviour of a program.

Session types~\cite{honda1993} provide static guarantees that concurrent
processes respect communication protocols, by specifying the expected structure
of communications among processes. Recently, work on
$\pi\text{DILL}~$\cite{caires2010} and CP~\cite{wadler2012} has yielded tight
correspondences between session typed $\pi$-calculi and intuitionistic and
classical linear logic~\cite{girard1987}, respectively.
These correspondences are tight in the following sense: not only do they
interpret session types as linear propositions, but they also show a
correspondence between reduction in the $\pi$-calculus and cut elimination in
linear logic.
Furthermore, by the very nature of their correspondence with linear logic,
programs in these calculi are guaranteed to be free from deadlocks.
Unfortunately, they are also free from \emph{races}.

% In this paper, we introduce \nodcap (nodcap), an extension of the type system
% CP~\cite{wadler2012} and inspired by bounded linear logic~\cite{girard1992},
% which allows non-determinism, and as such permits programs with races, without
% losing the tight correspondence with classical linear logic or the guarantee not
% to deadlock.

This paper presents \nodcap (nodcap), an extension of CP~\cite{wadler2012} with
a novel account of non-determinism and races.  Inspired by bounded linear
logic~\cite{girard1992}, we introduce a form of shared channels, in which the
type of a shared channel tracks how many times it is reused.  As in the untyped
$\pi$-calculus, sharing introduces the potential of non-determinism.  We show
that our approach is sufficient to capture practical examples of races, such as
the p\^atisserie, as well as other formal characterizations of non-determinism,
such as non-deterministic choice.  However, \nodcap does not abandon the
metatheoretical advantages of CP: we show that it preserves cut elimination, and
so \nodcap processes are still guaranteed to be deadlock-free.

% The paper is structured as follows. In the next section, we introduce the
% relevant variant of the $\pi$-calculus and its type system CP~\cite{wadler2012}.
% Then, we introduce the type system \nodcap.
% Following this, we and extend the proof of cut elimination for CP to cover
% \nodcap.
% Last, we discuss the types of concurrency that \nodcap allows us to capture.

The paper proceeds as follows.  Section~\ref{sec:background} introduces our
variant of the $\pi$-calculus and its type system CP~\cite{wadler2012}.
Section~\ref{sec:races} introduces \nodcap, our extension to CP, shows that cut
elimination for CP extends to \nodcap, guaranteeing deadlock freedom, and
discusses the types of concurrency captured by \nodcap.
Section~\ref{sec:conclusion} concludes with discussions of related and future work.
%
The type system and cut elimination procedure presented in the remainder of this
paper have been formalised using Agda~\cite{norell2009}, and the code is
available on GitHub.\footnote{%
  \url{https://github.com/pepijnkokke/nodcap}
}

\section{Background}
\label{sec:background}

In this section, we will discuss a rudimentary subset of the session-typed
process calculus CP~\cite{wadler2012}, which we will refer to as RCP.
Under the correspondence with linear logic, RCP corresponds to multiplicative
additive linear logic, often referred to as MALL.
The process calculus used by RCP is a variant of the
$\pi$-calculus~\cite{milner1992b}. Processes in RCP are defined by
the following grammar:
\[
  \begin{aligned}
    \red{P},\:&\red{Q},\red{R} ::=\\
    &       \red{\link{x}{y}}           &&\text{link}
    &\qquad&\red{\cut{x}(P \mid Q)}     &&\text{parallel composition}\\
    &       \red{\send{x}{y}(P \mid Q)} &&\text{``output''}
    &\qquad&\red{\recv{x}{y}P}          &&\text{``input''}\\
    &       \red{\inl{x}P}              &&\text{left selection}
    &\qquad&\red{\inr{x}P}              &&\text{right selection}\\
    &       \red{\case{x}{P}{Q}}        &&\text{choice}
    &\qquad&\red{\case{x}{}{}}          &&\text{empty choice}\\
    &       \red{\send{x}{}0}           &&\text{empty output}
    &\qquad&\red{\recv{x}{}P}           &&\text{empty input}\\
  \end{aligned}
\]
The construct $\link{x}{y}$ links two channels~\cite{sangiorgi1996,boreale1998},
forwarding messages received on $x$ to $y$ and vice versa.
%
The construct $\cut{x}{(P \mid Q)}$ creates a new channel $x$, and composes two
processes, which communicate on $x$, in parallel.
Therefore, in $\cut{x}{(P \mid Q)}$ the name $x$ is bound in both $P$ and $Q$.
%
In $\recv{x}{y}P$ and $\send{x}{y}P$, round brackets are used for input, square
brackets for output.
We use bound output~\cite{sangiorgi1996}---this means that unlike in the
$\pi$-calculus, both input and output bind a new name.
In $\recv{x}{y}P$ the new name $y$ is bound in $P$.
In $\send{x}{y}{(P \mid Q)}$, the new name $y$ is only bound in $P$, not in $Q$.

Processes in RCP are typed using session types which correspond to the
multiplicative and additive connectives from linear logic. These are defined
using the following grammar:
\[
  \begin{aligned}
    \blue{A},\:&\blue{B},\blue{C} ::=\\
    &       \tm{A \tens B} &&\text{`tensor', independent sessions A and B}
    &\qquad&\tm{\one}      &&\text{unit for \tens}\\
    &       \tm{A \parr B} &&\text{`par', possibly dependent sessions A and B}
    &\qquad&\tm{\bot}      &&\text{unit for \parr}\\
    &       \tm{A \plus B} &&\text{`plus', select session A or B}
    &\qquad&\tm{\nil}      &&\text{unit for \plus}\\
    &       \tm{A \with B} &&\text{`with', offer session A or B}
    &\qquad&\tm{\top}      &&\text{unit for \with}
  \end{aligned}
\]
We will discuss the interpretations of the connectives below, together with the
typing rules which introduce then.

Environments associate channels with types. They are defined as follows:
\[
  \blue{\Gamma},\blue{\Delta},\blue{\Theta} ::=
  \tm[x_1]{A_1},\tm[x_2]{A_2},\dots,\tm[x_n]{A_n}
\]
Note that each name in an environment should be unique. This means that $x_i
\neq x_j$ wherever $i \neq j$, and that environments $\Gamma$ and $\Delta$ can
only be combined as $\Gamma, \Delta$ if $\text{fv}(\Gamma) \cap
\text{fv}(\Delta) = \varnothing$.

Judgements indicate that a process $P$ communicates along each channels $x_i$
following the communication protocol specified by $A_i$. They are defined as
follows:
\[
  \seq[{ P }]{ \tm[x_1]{A_1},\tm[x_2]{A_2},\dots,\tm[x_n]{A_n} }
\]
The multiplicatives ($\tens$, $\parr$) deal with dependence and independence.
A channel of type $A \tens B$ represents a pair of channels which communicate
with two \emph{independent} processes---that is to say, two processes who share
no channels.
A channel of type $A \parr B$ represents a pair of channels which are used
within a single process. This means that their interactions can depend on one
another---i.e.\ the interaction of type $B$ could depend on the result of the
interaction of type $A$, or vice versa.
While the rules for $\tens$ and $\parr$ introduce input and output operations,
these are inessential---the essential distiction lies in the two independent
processes in $\tens$ as opposed to the single process in $\parr$. 
\begin{center}
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma , \tm[y]{A} }$}
    \AXC{$\seq[ Q ]{ \Delta , \tm[x]{B} }$}
    \SYM{\tens}
    \BIC{$\seq[{ \send{x}{y}(P \mid Q) }]{ \Gamma , \Delta , \tm[x]{A \tens B} }$}
  \end{prooftree*}
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma , \tm[y]{A} , \tm[x]{B} }$}
    \SYM{\parr}
    \UIC{$\seq[ \recv{x}{y}P ]{ \Gamma , \tm[x]{A \parr B} }$}
  \end{prooftree*}
\end{center}
The multiplicative units ($\one$, $\bot$) follow the same pattern.
A process with a channel of type $\one$ has no other channels, and therefore can
do nothing.
A process with a channel of type $\bot$ is not further restricted.
\begin{center}
  \begin{prooftree*}
    \AXC{}
    \SYM{\one}
    \UIC{$\seq[{ x[].0 }]{ \tm[x]{\one} }$}
  \end{prooftree*}
  \begin{prooftree*}
    \AXC{$\seq[P]{ \Gamma }$}
    \SYM{\bot}
    \UIC{$\seq[{x().P}]{ \Gamma , \tm[x]{\bot} }$}
  \end{prooftree*} 
\end{center}
The additives ($\plus$, $\with$) deal with choice---making choices and offering
them.
A process communicating over a channel of type $A \plus B$ can select either an
interaction of type $A$ or one of type $B$.
A process communicating over a channel of type $A \with B$ has to be prepared to
offer an interaction either of type $A$ or of type $B$.
\begin{center}
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma , \tm[x]{A} }$}
    \SYM{\plus_1}
    \UIC{$\seq[{ \inl{x}{P} }]{ \Gamma , \tm[x]{A \plus B} }$}
  \end{prooftree*}
  \begin{prooftree*}
    \AXC{$\seq[ P ]{ \Gamma , \tm[x]{A} }$}
    \AXC{$\seq[ Q ]{ \Delta , \tm[x]{B} }$}
    \SYM{\with}
    \BIC{$\seq[ \case{x}{P}{Q} ]{ \Gamma , \Delta , \tm[x]{A \with B} }$}
  \end{prooftree*}
\end{center}
The additive units ($\nil$, $\top$) follow the same pattern, except with nullary
instead of binary choices. That is to say, along a channel of type $\nil$, a
process has to select one of \emph{zero} options---this is, of course,
impossible. As such, there is no rule for $\nil$.
When communicating over a channel of type $\top$, a process has to be prepared
to offer any of \emph{zero} different interactions---which is, of course,
trivial.
\begin{center}
  \begin{prooftree*}
    \AXC{}
    \SYM{\top}
    \UIC{$\seq[ \case{x}{}{} ]{ \tm[x]{\top} }$}
  \end{prooftree*} 
\end{center}
Duality plays a crucial role in linear logic and session types. It ensures that
a process offering a choice on one end of a channel is matched with a process
which accepts a choice on the other. It is also crucial to deadlock freedom, as
it ensures that a process which uses communication on $x$ to decide what to send
on $y$ is communicating with two independent processes on $x$ and $y$,
preventing circular dependencies. Each type $A$ has a dual, defined as follows:
\[
  \begin{array}{ccccccc}
    \tm{( A \tens B )^\bot} = \tm{A^\bot \parr B^\bot}&&
    \tm{\one^\bot}          = \tm{\bot}&&
    \tm{( A \parr B )^\bot} = \tm{A^\bot \parr B^\bot}&&
    \tm{\bot^\bot}          = \tm{\one}\\
    \tm{( A \plus B )^\bot} = \tm{A^\bot \with B^\bot}&&
    \tm{\nil^\bot}          = \tm{\top}&&
    \tm{( A \with B )^\bot} = \tm{A^\bot \plus B^\bot}&&
    \tm{\top^\bot}          = \tm{\nil}
  \end{array}
\]
All typing rules for RCP are shown in Figure~\ref{fig:cp}.
%
\input{fig-cp}

\noindent
Let's briefly go back to our example of a deadlock:
\[\exampleprogramb\]
As CP and RCP are deadlock free, it should be obvious that there is no valid type
assignment for this program.
There are, however, two close variants which are typable.
These correspond to the programs in which John is given the power to decide
which of the goods is sent first, and that in which Mary is given that power.
The first of these is modeled in RCP by the program below, given that $\john$ is
a process which will receive money and send out cake, in any order, $\mary$ is a
process which will receive cake, $\dollar$ is a process which will send money,
$\money$ the type of money, $\plato$ is the type of $\cake$, and the
environments $\Gamma$, $\Delta$ and $\Theta$ summarise the remaining
interactions of John, Mary and the p\^atisserie with the rest of the world.
\begin{prooftree}
  \AXC{$\seq[{\john}]{\Gamma, \tm[y]{\money^\bot}, \tm[x]{\plato}}$}
  \SYM{\parr}
  \UIC{$\seq[{\recv{x}{y}\john}]{\Gamma, \tm[x]{\money^\bot \parr \plato}}$}
  \AXC{$\seq[{\dollar}]{\Delta, \tm[z]{\money}}$}
  \AXC{$\seq[{\mary}]{\Theta, \tm[x]{\plato^\bot}}$}
  \SYM{\tens}
  \BIC{$\seq[{\send{x}{z}(\dollar \mid \mary)}]{\Delta, \tm[x]{\money \tens \plato^\bot}}$}
  \NOM{Cut}
  \BIC{$\seq[{\cut{x}(\recv{x}{y}\john \mid \send{x}{z}(\dollar \mid \mary))}]{\Gamma, \Delta, \Theta}$}
\end{prooftree}
Note that the typing rule for $\tens$ forces Mary, who in our example sends
money to John and receives cake in return, to be represented by two
\emph{independent} processes $\dollar$ and $\mary$, one of which sends money, and
the other receives cake.\footnote{%
  There is a third variant of the deadlocked process which is harmless but
  \emph{not} well-typed in RCP. This is the variant in which \emph{both} John
  and Mary are powerless to decide which of the goods is sent first. This would
  be equivalent to assigning the types $\money^\bot \tens \plato$ and $\money
  \tens \plato^\bot$ to John and Mary, respectively. Such a program becomes
  typable in a version of CP extended with \textsc{Mix}~\cite{atkey2016}.
}

Under the correspondence with linear logic, communication in RCP is identified
with the elimination of the \textsc{Cut} rule. We can show that any term can be
systematically rewritten into a normal form in which all cuts are eliminated. We
present a proof of this here for reference, as we will extend it to cover
\nodcap in later sections:
\begin{quote}
  \textit{Proof sketch.}
  Given a program with one or more cuts, we select any such application $\cut{x}(P
  \mid Q)$ such that $P$ and $Q$ are in normal form.
  There are three cases:
  \begin{enumerate}
  \item
    If either $P$ or $Q$ is a link $\link{x}{y}$ we can eliminate the cut
    immediately, e.g.\ %
    \begin{center}
      \begin{prooftree*}
        \AXC{}
        \NOM{Ax}
        \UIC{$\seq[{ \link{y}{x} }]{ \tm[y]{A^\bot}, \tm[x]{A} }$}
        \AXC{$\seq[{ P }]{ \Gamma, \tm[x]{A^\bot} }$}
        \NOM{Cut}
        \BIC{$\seq[{ \cut{x}(\link{y}{x} \mid P) }]{ \Gamma, \tm[y]{A^\bot} }$}
      \end{prooftree*}
      $\Longrightarrow$
      \begin{prooftree*}
        \AXC{$\seq[{ \subst{P}{y}{x} }]{ \Gamma, \tm[y]{A^\bot} }$}
      \end{prooftree*}
    \end{center}
  \item
    If the last rules applied in $P$ and $Q$ both introduced the top-level
    connective in the type of $x$, then we apply any of the principal cut
    reductions, seen in Figure~\ref{fig:cp-cut-prin}. These replace a cut with
    one or more cuts on channels with a \emph{stricly smaller} type.
  \item
    Otherwise, we apply one of the commutative conversions for \textsc{Cut},
    seen in Figure~\ref{fig:cp-cut-cc}.\footnote{%
      In the interest of space, we are presenting the commutative conversions on
      terms alone.
      % For the full versions, which act on proofs, see the appendices (insert
      % reference here).
    }
    These move the application of \textsc{Cut} further into the term.
  \end{enumerate}
  We iteratively apply this procedure until there are no more applications of
  \textsc{Cut} left in the program.
\end{quote}
The proof above deviates from the proof given for CP~\cite{wadler2012}, which only
reduces top-level cuts in order to be consistent with the operational semantics
of the $\pi$-calculus.
%
We present the full version here in order to demonstrate that \nodcap enjoys
full cut elimination as well as the restricted version. 
%
A version of cut reduction which is similarily consistent with $\pi$-calculus
semantics can be obtained from the below proof by changing only selecting cuts
which are nested under applications of \textsc{Cut}, \textsc{Cont} and
\textsc{Pool}.
%
\input{fig-cp-cut-prin}
\input{fig-cp-cut-cc}


\section{Races in CP}
\label{sec:races}

In the previous section, we have seen RCP, and briefly discussed how it prevents
deadlocks. Let's now go back to our \emph{other} example, and see how RCP
prevents races:
\[\examplereductiona\]
Races occur when more than two processes attempt to communicate simultaneously
over the same channel.
However, the \textsc{Cut} rule only allows \emph{exactly two} processes to
communicate over a channel, and only if they use the channel dually:
\begin{prooftree}
  \AXC{$\seq[{P}]{\Gamma,\tm[x]{A}}$}
  \AXC{$\seq[{Q}]{\Delta,\tm[x]{A^\bot}}$}
  \NOM{Cut}
  \BIC{$\seq[{\cut{x}(P \mid Q)}]{\Gamma,\Delta}$}
\end{prooftree}
The racy behaviour in our example is intentional. Therefore, we would like to
extend RCP to also assign a type to this race. This essentially boils down to the
following question---what typing constructs do we need to complete the following
proof:\footnote{%
  It should be noted that $\cake$ and $\nocake$ are both considered to be of the
  type \plato, with $\nocake$ being the vastly more disappointing value of the
  cake type.
}
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tm[y]{\plato^\bot} }$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tm[z]{\plato^\bot} }$}
  \AXC{$\seq[{ \ptis }]{ \Theta, \tm[\cake]{\plato}, \tm[\nocake]{\plato} }$}
  \noLine\TIC{$\vdots$}\noLine
  \UIC{$\seq[{ \exampleprograma }]{ \Gamma, \Delta, \Theta }$}
\end{prooftree}
Ideally, we would use a regular \textsc{Cut} to introduce the channel $x$ in
this proof. We can do this if we group John and Mary on one side of the
\textsc{Cut}, and put the p\^atisserie on the other side. This seems
reasonable---John and Mary both try to get a cake, and the p\^atisserie offers
to try and provide a cake twice.
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tm[y]{\plato^\bot} }$}
  \noLine\UIC{$\vdots$}\noLine
  \AXC{$\seq[{ \mary }]{ \Delta, \tm[z]{\plato^\bot} }$}
  \noLine\UIC{$\vdots$}\noLine
  \BIC{$\seq[{ (\recv{x}{y}\john \mid \recv{x}{z}\mary) }]{ \Gamma, \Delta, \tm[x]{???^\bot} }$}
  \AXC{$\seq[{ \ptis }]{ \Theta, \tm[\cake]{\plato}, \tm[\nocake]{\plato} }$}
  \noLine\UIC{$\vdots$}\noLine
  \UIC{$\seq[{ \send{x}{\cake}\send{x}{\nocake}\ptis }]{\Theta, \tm[x]{???} }$}
  \NOM{Cut}
  \BIC{$\seq[{ \exampleprograma }]{ \Gamma, \Delta, \Theta }$}
\end{prooftree}
Furthermore, the actions of John and Mary are completely independent, whereas
for the p\^atisserie its actions are order dependent---it will ship a slice of
cake first, and only then ship disappointment.
This makes it seem like we could fill in the $???$ with the type
$\plato^\bot \parr \plato^\bot$.
\def\exampleprogramc{\red{\ensuremath{%
      \cut{x}(\send{x}{y}(\john \mid \mary) \mid \recv{x}{z}\ptis)
    }}}%
We would implement our ``race'' with the program below:
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tm[y]{\plato^\bot} }$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tm[x]{\plato^\bot} }$}
  \SYM{\tens}
  \BIC{$\seq[{ \send{x}{y}(\john \mid \mary) }]{ \Gamma, \Delta,
      \tm[x]{\plato^\bot \tens \plato^\bot} }$}
  \AXC{$\seq[{ \ptis }]{ \Theta, \tm[x]{\plato}, \tm[z]{\plato} }$}
  \SYM{\parr}
  \UIC{$\seq[{ \recv{z}{x}\ptis }]{ \Theta, \tm[x]{\plato \parr \plato} }$}
  \NOM{Cut}
  \BIC{$\seq[{ \exampleprogramc }]{ \Gamma, \Delta, \Theta }$}
\end{prooftree}
However, we would be giving the choice of who receives the cake to the
p\^atisserie. This no longer accurately models our example, where the choice of
who receives the cake is non-deterministic, and depends on factors outside of
the p\^atisserie's control---i.e.\ on who happens to place their order first.

Thus, we add a new dual pair of connectives to RCP---$\give[n]{A}$ (give) and
$\take[n]{A}$ (take). $\give[n]{A}$ denotes a channel with $n$ dependent
interactions of type $A$, and $\take[n]{A}$ denotes a channel with $n$
independent interactions of type $A$---the same dependence/independence
distinction that par and tensor make, but with a non-deterministic reduction
behaviour.
They are labeled with a positive natural number $n$, which ensures that there
are sufficient server resources for every client, and sufficent clients for each
server.

In the following two subsections, we will look at the two sides of the
\textsc{Cut} in our incomplete proof, describe the rules we add for `give' and
`take', and show how they allow us to complete our proof.
The complete set of rules added in \nodcap can be found in
Figure~\ref{fig:nodcap}.


\subsection*{Servers and contraction}
Our intepretation of a server is any process which offers up a sequence of
identically typed interactions which are dependent on one another. Examples are
our p\^atisserie, which gives out cake until it runs out, a ticket server which
hands out numbered tickets in order, etc.
We introduce two new rules to construct servers. The first, $\give[1]{}$, marks
a channel as a server interaction. It does this by sending the channel $y$
across a channel $x$.\footnote{%
  Ultimately, it does not matter whether this rule is implemented with a send or
  a receive action. All that matters is that $\give[1]{}$ and $\take[1]{}$
  introduce dual operations---a send and a receive.
}
The second rule, \textsc{Cont}, enables the contraction of server interactions.
This enables us to construct a server which has multiple interactions of the
same type across the same channel $x$.
\begin{center}
  \begin{prooftree*}
    \AXC{$\seq[{P}]{ \Gamma , \tm[y]{A} }$}
    \SYM{\give[1]{}}
    \UIC{$\seq[{ \give{\send{x}{y}}P }]{ \Gamma , \tm[x]{\give[1]{A}} }$}
  \end{prooftree*}
  \begin{prooftree*}
    \AXC{$\seq[{ P }]{ \Gamma , \tm[x]{\give[m]{A}} , \tm[y]{\give[n]{A}} }$}
    \NOM{Cont}
    \UIC{$\seq[{ \subst{P}{x}{y} }]{ \Gamma , \tm[x]{\give[m+n]{A}} }$}
  \end{prooftree*}
\end{center}
Using these rules, we can derive the right-hand side of our proof by marking
each of the p\^atisserie's interactions as server interactions, and then
contracting them:
\begin{prooftree}
  \AXC{$\seq[{ \ptis }]{ \Theta, \tm[\cake]{\plato}, \tm[\nocake]{\plato} }$}
  \SYM{\give[1]{}}
  \UIC{$\seq[{ \give{\send{x'}{\nocake}}\ptis }]{
      \Theta, \tm[\cake]{\plato}, \tm[x']{\give[1]{\plato}} }$}
  \SYM{\give[1]{}}
  \UIC{$\seq[{ \give{\send{x}{\cake}}\give{\send{x'}{\nocake}}\ptis }]{
      \Theta, \tm[x]{\give[1]{\plato}}, \tm[x']{\give[1]{\plato}} }$}
  \NOM{Cont}
  \UIC{$\seq[{ \give{\send{x}{\cake}}\give{\send{x}{\nocake}}\ptis }]{
      \Theta, \tm[x]{\give[2]{\plato}} }$}
\end{prooftree}


\subsection*{Clients and pooling}
The dual of a server is not a client, but a pool of clients---a number of
independent processes which each wish to have an interaction with the
server. Examples are our processes John and Mary, customers to ticket servers,
etc. We introduce two new rules---one to construct clients and one to
\emph{pool} them together. The first, $\take[1]{}$, marks an interaction as a
client interaction. It does this by receiving the channel $y$, across which the
actual interaction will take place, over some shared channel $x$.
The second rule, \textsc{Pool}, enables us to pool together clients. This is
implemented using a $\pi$-calculus parallel composition, which puts together two
client pools, in which each client attempts to interact across $x$.
\begin{center}
  \begin{prooftree*}
    \AXC{$\seq[{ P }]{ \Gamma , \tm[y]{A} }$}
    \SYM{\take[1]{}}
    \UIC{$\seq[{ \take{\recv{x}{y}}P }]{ \Gamma , \tm[x]{\take[1]{A}} }$}
  \end{prooftree*}
  \begin{prooftree*}
    \AXC{$\seq[{ P }]{ \Gamma , \tm[x]{\take[m]{A}} }$}
    \AXC{$\seq[{ Q }]{ \Delta , \tm[x]{\take[n]{A}} }$}
    \NOM{Pool}
    \BIC{$\seq[{ (P \mid Q) }]{ \Gamma , \Delta , \tm[x]{\take[m+n]{A}} }$}
  \end{prooftree*}
\end{center}
Using these rules, we can derive the left-hand side of our proof by marking John
and Mary as clients looking for cake, and pooling them together:
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tm[y]{\plato^\bot} }$}
  \SYM{\take[1]{}}
  \UIC{$\seq[{ \take{\recv{x}{y}}\john }]{ \Gamma, \tm[x]{\take[1]{\plato^\bot}} }$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tm[z]{\plato^\bot} }$}
  \SYM{\take[1]{}}
  \UIC{$\seq[{ \take{\recv{x}{z}}\mary }]{ \Delta, \tm[x]{\take[1]{\plato^\bot}} }$}
  \SYM{}
  \BIC{$\seq[{ (\take{\recv{x}{y}}\john \mid \take{\recv{x}{z}}\mary) }]{
      \Gamma, \Delta, \tm[x]{\take[2]{\plato^\bot}} }$}
\end{prooftree}
Thus, we complete the derivation of our example.
%
\input{fig-nodcap}


\subsection*{Non-deterministic communication and cut elimination}
All that remains is to show that the proof of cut elimination for RCP can be
extended to cover \nodcap. In order to show this, we need to do two things.
We need to
\begin{enumerate}
\item
  give \emph{four} new commutative conversion, in order to show that
  \textsc{Cut} commutes with the four new proof rules we have introduced; and
\item
  give \emph{one} new principal cut reduction, to show that we can reduce a cut
  on a channel of type $\give[n]{A}$/$\take[n]{A}$ to a number of smaller cuts.
\end{enumerate}
The commutative conversions are shown in Figure~\ref{fig:nodcap-cut}.
%
\input{fig-nodcap-cut}
%
All that remains is to give a reduction rule for a cut between a server and a
client pool:
\begin{prooftree}
  \AXC{$\seq[{ P }]{ \Gamma, \tm[x]{\give[n]{A^\bot}}}$}
  \AXC{$\seq[{ R }]{ \Delta, \tm[x]{\take[n]{A}} }$}
  \NOM{Cut}
  \BIC{$\seq[{ \cut{x}(P \mid R) }]{ \Gamma, \Delta }$}
\end{prooftree}
In order to do this, we introduce two new admissible rules---server expansion,
and client interleaving:
\begin{center}
  \begin{scprooftree*}[0.90]
    \AXC{$\seq[{ P }]{ \Gamma, \tm[x]{\give[n]{A}} }$}
    \NOM{Exp}
    \UIC{$\seq[{ \expn{x}{x_1 \cdots x_n}P }]{ \Gamma, \tm[x_1]{A} \cdots \tm[x_n]{A} }$}
  \end{scprooftree*}%
  \begin{scprooftree*}[0.90]
    \AXC{$\seq[{ P }]{ \Delta, \tm[y]{\take[n]{A}} }$}
    \AXC{$\seq[{ Q }]{ \Gamma, \tm[x_1]{A^\bot} \cdots \tm[x_n]{A^\bot} }$}
    \NOM{Int}
    \BIC{$\seq[{ \intl{y}{x_1 \cdots x_n}(P \mid Q) }]{ \Gamma, \Delta }$}
  \end{scprooftree*}
\end{center}
We can compose these rules to eliminate the above cut (see
Figure~\ref{fig:nodcap-cut}).
%
However, this has simply moved the problem. How do we eliminate applications of
\textsc{Exp} and \textsc{Int}? This involves two more proofs with the exact same
structure as that of cut elimination.

The principal eliminations and commutative conversions for \textsc{Exp} are
shown in Figure~\ref{fig:nodcap-expn}. When we put these together, we see that
the operation $\expn{x}{x_1 \dots x_n}P$ strips all the applications of
$\give[1]{}$ and \textsc{Cont} from a program, and renames the channels which
were marked as server interactions using the names $x_1 \dots x_n$.
%
\input{fig-nodcap-expn}

The principal eliminations and commutative conversions for \textsc{Int} are
shown in Figure~\ref{fig:nodcap-intl}. When we put these together, we see that
the operation $\intl{x}{y_1 \dots y_n}(P \mid Q)$ joins each interaction $y_i$
with some dual interaction from the client pool. This means that each
interleaving reduces to $n$ cuts, where $n$ is the number of clients.
%
\input{fig-nodcap-intl}

So, where does the non-determinism come in? All the interactions in our cut are
of the same \emph{same} type. When eliminating the cut, there is an inherent
choice---for it does not matter which client we connect to which server
interaction. Therefore, we apply a permutation $\pi$ to the names in our cut
reduction (see Figure~\ref{fig:nodcap-cut-prin}).

Let us go back to our example. We can now assign a type to this program, and
consider its reduction behaviour as a result of cut elimination. See
Figure~\ref{fig:cut-ex}.
%
\input{fig-cut-ex}

\subsection*{\nodcap and non-deterministic choice}
Recent work by~\cite{caires2014,caires2017,atkey2016} has seen the extension of
$\pi\text{DILL}$ and CP with non-deterministic
choice~\cite{milner1992b}. Though there are differences between the
various referenced articles, in the context of $\pi\text{DILL}$ and CP this
operator can essentially be summarised with the following typing rule and
reduction semantics:
\begin{center}
  \begin{prooftree*}
    \AXC{$\seq[{P}]{\Gamma}$}
    \AXC{$\seq[{Q}]{\Gamma}$}
    \BIC{$\seq[{P+Q}]{\Gamma}$}
  \end{prooftree*}
  \hspace*{2cm}
  \(\!
  \begin{aligned}
    \red{P+Q} \Longrightarrow \red{P}\\
    \red{P+Q} \Longrightarrow \red{Q}
  \end{aligned}
  \)
\end{center}
This operator is derivable in \nodcap. We can derive the non-deterministic
choice $P+Q$ for a single channel by combining the following two terms with
\textsc{Cut}:
\begin{prooftree}
  \AXC{$\seq[{P}]{\Gamma, \tm[y]{A}}$}
  \SYM{\with}
  \UIC{$\seq[{\case{y}{\halt{y}}{P}}]{
      \Gamma, \tm[y]{\one \with A}}$}
  \SYM{\take[1]{}}
  \UIC{$\seq[{\take{\recv{x}{y}}\case{y}{\halt{y}}{P}}]{
      \Gamma, \tm[x]{\take[1]{(\one \with A)}}}$}
  \AXC{$\seq[{Q}]{
      \Delta, \tm[z]{A}}$}
  \SYM{\with}
  \UIC{$\seq[{\case{z}{\halt{z}}{Q}}]{
      \Delta, \tm[z]{\one \with A}}$}
  \SYM{\take[1]{}}
  \UIC{$\seq[{\take{\recv{x}{z}}\case{z}{\halt{z}}{Q}}]{
      \Delta, \tm[x]{\take[1]{(\one \with A)}}}$}
  \NOM{Pool}
  \BIC{$\seq[{(
      \take{\recv{x}{y}}\case{y}{\halt{y}}{P} \mid
      \take{\recv{x}{z}}\case{z}{\halt{z}}{Q}
      )}]{\Gamma, \Delta, \tm[x]{\take[2]{\one \with A}}}$}
\end{prooftree}
\begin{prooftree}
  \AXC{}
  \NOM{Ax}
  \UIC{$\seq[{
      \link{z}{w}
    }]{\tm[z]{A^\bot}, \tm[w]{A}}$}
  \SYM{\plus_1}
  \UIC{$\seq[{
      \inr{z}\link{z}{w}
    }]{\tm[z]{\bot \plus A^\bot}, \tm[w]{A}}$}
  \SYM{\bot}
  \UIC{$\seq[{
      \wait{y}\inr{z}\link{z}{w}
    }]{\tm[y]{\bot}, \tm[z]{\bot \plus A^\bot}, \tm[w]{A}}$}
  \SYM{\plus_1}
  \UIC{$\seq[{
      \inl{y}\wait{y}\inr{z}\link{z}{w}
    }]{\tm[y]{\bot \plus A^\bot}, \tm[z]{\bot \plus A^\bot}, \tm[w]{A}}$}
  \SYM{\give[1]{(2)}}
  \UIC{$\seq[{
      \give{\send{x}{y}}\give{\send{x'}{z}}\inl{y}\wait{y}\inr{z}\link{z}{w}
    }]{\tm[x]{\give[1]{(\bot \plus A^\bot)}}, \tm[x']{\give[1]{(\bot \plus A^\bot)}}, \tm[w]{A}}$}
  \NOM{Cont}
  \UIC{$\seq[{
      \give{\send{x}{y}}\give{\send{x}{z}}\inl{y}\wait{y}\inr{z}\link{z}{w}
    }]{\tm[x]{\give[2]{(\bot \plus A^\bot)}, \tm[w]{A}}}$}
\end{prooftree}
And we can derive full non-deterministic choice using the invertability of
$\parr$.


\section{Related and Future Work}
\label{sec:conclusion}

\subsection*{Relation with bounded linear logic}
We mentioned in Section~\ref{sec:introduction} that \nodcap was inspired by
bounded linear logic~\cite[BLL]{girard1992}. BLL is a typed lambda calculus
based on intuitionistic linear logic which guarantees that its programs are
polynomial-time functions.
It too uses resource-indexed exponentials. However, instead of interpreting
these as client and server interactions, BLL interprets them as accesses to a
memory cell, as is a common interpretation in linear logic~\cite{girard1987}.
There are some superficial differences between BLL and \nodcap, e.g.\ the former
is intuitionistic while the latter is classical, but the main difference between
the two lies in storage versus pooling. In BLL, $\take[n]{A}$ denotes a memory
cell which can be accessed $n$ times, whereas in \nodcap, $\take[n]{A}$
represents a pool of $n$ different values, computed independently by $n$
different processes.

\subsection*{Relation with recursion}
We would like to be able to construct servers by recursion. This is not possible
in \nodcap as presented here.
A recent extension of CP, $\mu\text{CP}$~\cite{lindley2016}, adds primitives for
structural recursion.
If we added these primitives to \nodcap, we would be able to construct servers
from streams of type $\nu X.A \parr (\one \plus X)$.

\subsection*{\red{TODO?} Resource variables and quantification}
\begin{itemize}
\item
  Mention the idea of resource variables and quantification.
\item
  Mention the idea of embedding CP into this framework, using the encoding:
  \[
    \take{A} := \forall{n}\take[n]{A}
    \quad\text{and}\quad
    \give{A} := \exists{n}{\give[n]{A}}
  \]
\item
  Mention the ideal types for servers and clients:
  \[
    \text{Server}(A) := \forall{n}\give[n]{A}
    \quad\text{and}\quad
    \text{Clients}(A) := \exists{n}{\take[n]{A}}.
  \]
\end{itemize}

\clearpage
\bibliography{main}

\end{document}
%%% Local Variables:
%%% TeX-master: "main"
%%% fill-column: 80
%%% End:
