\documentclass[a4paper,UKenglish]{lipics-v2016}
\usepackage{microtype}%
\bibliographystyle{plainurl}%
% Author macros::begin 
\title{Give or Take: Non-Determinism, Linearity, and Session Types}%
\titlerunning{Give or Take}%
\author[1]{Pepijn Kokke}%
\affil[1]{LFCS, University of Edinburgh, Edinburgh, United Kingdom\\
  \texttt{pepijn.kokke@ed.ac.uk}}%
\authorrunning{P. Kokke}%
\Copyright{Pepijn Kokke}%
\subjclass{
  F.4.1. [Mathematical Logic]: Lambda calculus and related systems;
  D.3.1. [Formal Definitions and Theory]: Syntax;
  D.3.2. [Language Classifications] Concurrent, distributed, and parallel languages
}%
\keywords{$\pi$-calculus, linear logic, session types, deadlock free, non-determinism}
% Author macros::end

% Editor-only macros::begin
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important (Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end

% Preamble macros::begin
\input{preamble}
% Preamble macros::end

\begin{document}

\maketitle

\begin{abstract}
  The $\pi$-calculus is a great foundation for concurrent programming languages.
  With only a handful of constructions, it manages to model communicating
  processes faithfully---for instance, $\pi$-calculus programs can have races
  and deadlocks. 
  CP~\cite{wadler2012} is a session type system for the $\pi$-calculus, which
  has strong ties to classical linear logic~\cite{girard1987}. Programs typed by
  CP are guaranteed to be race and deadlock free. 
  Under the slogan that ``well-typed programs cannot `go wrong'\!\!
  ''~\cite{milner1978}, it makes sense to exclude deadlocks, as one rarely
  \emph{wants} a program to deadlock. 
  Races, on the other hand, may be the desired behaviour of a program---think
  of online auctions, vendors, or any other scenario where several processes
  compete for a limited resource. 

  In this paper, we introduce \nodcap\ (Nodcap), an extension of CP which is more
  permissive, and permits programs with races, without losing its strong ties
  to classical linear logic or the guarantee of deadlock freeness. 
\end{abstract}

\section{Overview}
\begin{itemize}
%\item Introduction
%  \begin{itemize} 
%  \item introduce example (racy vendor interaction)
%  \item mention that the $\pi$-calculus can model this example
%  \item mention the downsides of the $\pi$-calculus (i.e. deadlock)
%  \item mention that CP prevents deadlock
%  \item mention that CP \emph{cannot} model this example
%  \end{itemize}
\item Background
  \begin{itemize}
  \item introduce the $\pi$-calculus
  \item introduce CP
  \item mention local choice
  \end{itemize}
\item Main contribution
  \begin{itemize}
  \item introduce typing rules for \nodcap
  \item introduce evaluation for programs in \nodcap
  \item sketch a proof for server expansion
  \item sketch a proof for client interleaving
  \item sketch a proof for communication
  \end{itemize}
\item Extensions and future work
  \begin{itemize}
  \item mention relation to local choice (and proper cut elimination)
  \item mention possibility of recursion and creating servers from streams
  \item mention possibility of resource quantifiers
  \end{itemize} 
\end{itemize}

\section{Introduction}
Imagine the following scenario:
\begin{quote}
  John and Mary are working from home one morning when they each get a craving
  for a slice of cake. Being denizens of the web, they quickly find an nearby
  p\^atisserie that does home deliveries. Unfortunately for them, they both
  order their cake at the \emph{same} p\^atisserie, which has only one slice
  left. After that, all it can deliver is disappointment. 
\end{quote}
This scenario is a classic example of a race condition, and it is modeled in the
$\pi$-calculus by the program below, given that \john, \mary, and \ptis\ are
processes representing John, Mary and the p\^atisserie, respectively, and
\cake\ and \nocake\ are two channels over which \ptis\ will send a slice of
cake, and disappointment, respectively.
The arrows indicate two possible reductions of the program: one in which John
gets the cake and Mary is disappointed, and one in which Mary gets cake and John
is disappointed.  
\[
  \def\exampleprograma{\red{\ensuremath{%
        \cut{x}(\recv{x}{y}\john \mid \recv{x}{z}\mary \mid
        \send{x}{\cake}\send{x}{\nocake}\ptis)
      }}}
  \def\exampleresultaa{\red{\ensuremath{%
        \cut{x}(\subst{\john}{\cake}{y} \mid \subst{\mary}{\nocake}{z} \mid \ptis)     
      }}}
  \def\exampleresultab{\red{\ensuremath{%
        \cut{x}(\subst{\john}{\nocake}{y} \mid \subst{\mary}{\cake}{z} \mid \ptis)     
      }}}
  \begin{tikzpicture}
    \node (program) at (0,0) {$\exampleprograma\quad$};
    \node[above=1cm, right=1cm, at=(program.east)] (resulta)
    {$\!\!^\star\quad\exampleresultaa$};
    \node[below=1cm, right=1cm, at=(program.east)] (resultb)
    {$\!\!^\star\quad\exampleresultab$};
    \draw[->] (program.east) to [out=045,in=180] (resulta.west);
    \draw[->] (program.east) to [out=315,in=180] (resultb.west);
  \end{tikzpicture}
\]
Races show up in any client/server system where clients compete for limited
server resources. It is therefore important that any concurrent programming
language allows us to write them.
\\
It should be obvious from the above example that the $\pi$-calculus is up to the
task of modeling such programs. However, it can also model some undesirable
programs, programs which `go wrong'. An example of such a program is the
following scenario:  
\begin{quote}
  John managed to order the last slice of cake from the p\^atisserie. However,
  Mary \emph{really} wants it, and offers him some money for it. John agrees,
  but sadly there is no trust between the two. Mary demands to get the cake
  first, before she gives John the money. John demands to get the money first,
  before he gives Mary the cake.
\end{quote}
This scenario is a classic example of a deadlock, and it is modeled in the
$\pi$-calculus by the program below, given that \john\ and \mary\ are processes 
representing John and Mary, respectively, \cake\ is a channel over which
\john\ will send a slice of cake, and \money\ is a channel over which \mary\ %
will send money.
\[
  \def\exampleprogramb{\red{\ensuremath{%
        \cut{x}(\recv{x}{y}\send{x}{\cake}\john \mid \recv{x}{z}\send{x}{\money}\mary)
      }}}
  \exampleprogramb
\]
The program is stuck---John is refusing to send the cake until he receives money
from Mary, and Mary is refusing to send the money until John sends the cake, so
nothing will actually happen.
It `goes wrong', in the sense that a deadlock is unlikely to be the intended
behaviour of a program. 

Session types, a formalism proposed by~\cite{honda1993}, can provide static
guarantees that concurrent processes respect communication protocols, by
specifying the expected structure of communications among processes.
Recently, work by~\cite{caires2010} and~\cite{wadler2012} has yielded tight
correspondences between session typed $\pi$-calculi and intuitionistic and
classical linear logic~\cite{girard1987}, respectively.
These correspondences are tight in the following sense: not only do they
interpret session types as linear propositions, but they also show a
correspondence between reduction in the $\pi$-calculus and cut elimination in
linear logic.
Furthermore, by the very nature of their correspondence with linear logic,
programs in these calculi are guaranteed to be free from deadlocks.
Unfortunately, they are also free from \emph{races}.

In this paper, we introduce \nodcap\ (Nodcap), an extension of the type system
CP~\cite{wadler2012} which is more permissive, and permits programs with races,
without losing the tight correspondence with classical linear logic or the
guarantee of deadlock. 
The paper is structured as follows. In the next section, we introduce the
relevant variant of the $\pi$-calculus and its type system CP~\cite{wadler2012}. 
Then, we introduce the type system \nodcap.
Following this, we and extend the proof of cut elimination for CP to cover
\nodcap.
Last, we discuss the types of concurrency that \nodcap\ allows us to capture.

The type system and cut elimination procedure presented in the remainder of this
paper have been formalised using the Agda proof assistent~\cite{norell2009}, and
the code is available on GitHub.\footnote{
  \red{Insert GitHub URL here.}
}

\section{Background}
In this section, we will discuss a rudimentary subset of the session-typed
process calculus CP~\cite{wadler2012}, which we will refer to as RCP.
Under the correspondence with linear logic, RCP corresponds to multiplicative
additive linear logic (MALL).
The process calculus used by RCP is a variant of the
$\pi$-calculus~\cite{milner1992}. Processes in RCP are defined by the following
grammar:
\[
  \begin{aligned}
    \red{P},\:&\red{Q},\red{R} ::=\\
    & \red{\link{x}{y}}           &&\text{link}
    &&\red{\cut{x}(P \mid Q)}     &&\text{parallel composition}\\
    & \red{\send{x}{y}(P \mid Q)} &&\text{output}
    &&\red{\recv{x}{y}P}          &&\text{input}\\
    & \red{\inl{x}P}              &&\text{left selection}
    &&\red{\inr{x}P}              &&\text{right selection}\\
    & \red{\case{x}{P}{Q}}        &&\text{choice}
    &&\red{\case{x}{}{}}          &&\text{empty choice}\\
    & \red{\send{x}{y}0}          &&\text{empty output}
    &&\red{\recv{x}{y}P}          &&\text{empty input}\\
  \end{aligned}
\]
The construct $\link{x}{y}$ links two channels, forwarding messages received on
$x$ to $y$ and vice versa.
%
The construct $\cut{x}{(P \mid Q)}$ creates a new channel $x$, and composes two
processes, which communicate on $x$, in parallel.
Therefore, in $\cut{x}{(P \mid Q)}$ the name $x$ is bound in both $P$ and $Q$. 
%
Round brackets are used for input, square brackets for output.
We use bound output~\cite{sangiorgi1996}---this means that unlike in the
$\pi$-calculus, both input and output bind a new name.
In $\recv{x}{y}P$ the new name $y$ is bound in $P$.
In $\send{x}{y}{(P \mid Q)}$, the new name $y$ is only bound in $P$, not in $Q$.

Processes in RCP are typed using session types which correspond to the
multiplicative and additive connectives from linear logic. These are defined
using the following grammar:
\[
  \begin{aligned}
    \blue{A},\:&\blue{B},\blue{C} ::=\\
    & \tm{A \tens B} &&\text{`tensor', independent sessions A and B}
    &&\tm{\one}      &&\text{unit for \tens}\\
    & \tm{A \parr B} &&\text{`par', possibly dependent sessions A and B}
    &&\tm{\bot}      &&\text{unit for \parr}\\
    & \tm{A \plus B} &&\text{`plus', select session A or B}
    &&\tm{\nil}      &&\text{unit for \plus}\\
    & \tm{A \with B} &&\text{`with', offer session A or B}
    &&\tm{\top}      &&\text{unit for \with}
  \end{aligned}
\]
The multiplicatives ($\tens$, $\parr$) deal with dependence and independence.
A channel of type $A \tens B$ represents a pair of channels which communicate
with two \emph{indepentent} processes---that is to say, two processes who share
no channels.
A channel of type $A \parr B$ represents a pair of channels which are used
within a single process. This means that their interactions can depend on one
another---i.e.\ the interaction of type $B$ could depend on the result of the
interaction of type $A$, or vice versa.
The multiplicative units ($\one$, $\bot$) follow the same pattern.
A channel of type $\one$ communicates with a process which has no other
channels, and therefore can do nothing.
A channel of type $\bot$ communicates with a process which is not further
restricted.

The additives ($\plus$, $\with$) deal with choice---making choices and offering
them.
A process communicating over a channel of type $A \plus B$ can select either an
interaction of type $A$ or one of type $B$. 
A process communicating over a channel of type $A \with B$ has to be prepared to
offer an interaction either of type $A$ or of type $B$. 
The additive units ($\nil$, $\top$) follow the same pattern, except with nullary
instead of binary choices. That is to say, along a channel of type $\nil$, one
has to select one of \emph{zero} options---which is, of course, impossible.
Therefore, when communicating over a channel of type $\top$, one has to be
prepared to offer any of \emph{zero} different interactions---which is, of
course, trivial.

Duality plays a crucial role in linear logic and session types. It ensures that
a process offering a choice on one end of a channel is matched with a process
which accepts a choice on the other. It is also crucial to deadlock freedom, as
it ensures that a process which uses communication on $x$ to decide what to send
on $y$ is communicating with two independent processes on $x$ and $y$,
preventing circular dependencies. Each type $A$ has a dual, defined as follows:
\[
  \begin{array}{rclcrcl}
    \tm{( A \tens B )^\bot} &=& \tm{A^\bot \parr B^\bot}&&
    \tm{\one^\bot}          &=& \tm{\bot}\\
    \tm{( A \parr B )^\bot} &=& \tm{A^\bot \parr B^\bot}&&
    \tm{\bot^\bot}          &=& \tm{\one}\\
    \tm{( A \plus B )^\bot} &=& \tm{A^\bot \with B^\bot}&&
    \tm{\nil^\bot}          &=& \tm{\top}\\
    \tm{( A \with B )^\bot} &=& \tm{A^\bot \plus B^\bot}&&
    \tm{\top^\bot}          &=& \tm{\nil}
  \end{array}
\]
Environments associate names with types. They are defined as follows:
\[
  \blue{\Gamma},\blue{\Delta},\blue{\Theta} ::=
  \tm[x_1]{A_1},\tm[x_2]{A_2},\dots,\tm[x_n]{A_n}
\]
Note that each name in an environment should be unique. This means that $x_i
\neq x_j$ wherever $i \neq j$, and that environments $\Gamma$ and $\Delta$ can
only be combined if $\text{fv}(\Gamma) \cap \text{fv}(\Delta) = \emptyset$.

Judgements indicate that a process $P$ communicates along each channels $x_i$
following the communication protocol specified by $A_i$. They are defined as
follows:
\[
  \seq[{ P }]{ \tm[x_1]{A_1},\tm[x_2]{A_2},\dots,\tm[x_n]{A_n} }
\]
The rules for assigning session types to processes in RCP are shown in
Figure~\ref{fig:cp}.

\input{fig-cp}

% \input{fig-nodcap}
%\input{fig-nodcap-ax}
%\input{fig-nodcap-expn-prin}
%\input{fig-nodcap-expn-cc}
%\input{fig-nodcap-intl-prin}
%\input{fig-nodcap-intl-cc}
%\input{fig-nodcap-cut-prin}
%\input{fig-nodcap-cut-perm}

\clearpage
\bibliography{main}

\end{document}

%%% Local Variables:
%%% TeX-master: "main"
%%% End:
