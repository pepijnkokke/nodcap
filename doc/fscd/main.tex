\documentclass[a4paper,UKenglish]{lipics-v2016}
\usepackage{microtype}%
\bibliographystyle{plainurl}%
% Author macros::begin
\title{Give or Take: Non-Determinism, Linearity, and Session Types}%
\titlerunning{Give or Take}%
\author[1]{Pepijn Kokke}%
\affil[1]{LFCS, University of Edinburgh, Edinburgh, United Kingdom\\
  \texttt{pepijn.kokke@ed.ac.uk}}%
\authorrunning{P. Kokke}%
\Copyright{Pepijn Kokke}%
\subjclass{
  F.4.1. [Mathematical Logic]: Lambda calculus and related systems;
  D.3.1. [Formal Definitions and Theory]: Syntax;
  D.3.2. [Language Classifications] Concurrent, distributed, and parallel languages
}%
\keywords{$\pi$-calculus, linear logic, session types, deadlock freedom, non-determinism}
% Author macros::end

% Editor-only macros::begin
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important (Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end

% Preamble macros::begin
\input{preamble}
% Preamble macros::end

\begin{document}

\maketitle

\begin{abstract}
  The $\pi$-calculus is a great foundation for concurrent programming languages.
  With only a handful of constructions, it manages to model communicating
  processes faithfully---for instance, $\pi$-calculus programs can have races
  and deadlocks.
  CP~\cite{wadler2012} is a session type system for the $\pi$-calculus, which
  has strong ties to classical linear logic~\cite{girard1987}. Programs typed by
  CP are guaranteed to be race and deadlock free.
  Under the slogan that ``well-typed programs cannot `go wrong'\!\!
  ''~\cite{milner1978}, it makes sense to exclude deadlocks, as one rarely
  \emph{wants} a program to deadlock.
  Races, on the other hand, may be the desired behaviour of a program---think
  of online auctions, vendors, or any other scenario where several processes
  compete for a limited resource.

  In this paper, we introduce \nodcap\ (Nodcap), an extension of CP which is more
  permissive, and permits programs with races, without losing its strong ties
  to classical linear logic or the guarantee of deadlock freeness.
\end{abstract}

\section{Overview}
\begin{itemize}
%\item Introduction
%  \begin{itemize}
%  \item introduce example (racy vendor interaction)
%  \item mention that the $\pi$-calculus can model this example
%  \item mention the downsides of the $\pi$-calculus (i.e. deadlock)
%  \item mention that CP prevents deadlock
%  \item mention that CP \emph{cannot} model this example
%  \end{itemize}
%\item Background
%  \begin{itemize}
%  \item introduce the $\pi$-calculus
%  \item introduce CP
%  \item mention local choice
%  \end{itemize}
\item Main contribution
  \begin{itemize}
% \item introduce typing rules for \nodcap
  \item introduce evaluation for programs in \nodcap
  \item sketch a proof for server expansion
  \item sketch a proof for client interleaving
  \item sketch a proof for communication
  \end{itemize}
\item Extensions and future work
  \begin{itemize}
  \item mention relation to local choice (and proper cut elimination)
  \item mention possibility of recursion and creating servers from streams
  \item mention possibility of resource quantifiers
  \end{itemize}
\end{itemize}

\section{Introduction}
Imagine the following scenario:
\begin{quote}
  John and Mary are working from home one morning when they each get a craving
  for a slice of cake. Being denizens of the web, they quickly find an nearby
  p\^atisserie that does home deliveries. Unfortunately for them, they both
  order their cake at the \emph{same} p\^atisserie, which has only one slice
  left. After that, all it can deliver is disappointment.
\end{quote}
This scenario is a classic example of a race condition, and it is modeled in the
$\pi$-calculus by the program below, given that \john, \mary, and \ptis\ are
processes representing John, Mary and the p\^atisserie, respectively, and
\cake\ and \nocake\ are two channels over which \ptis\ will send a slice of
cake, and disappointment, respectively.
The arrows indicate two possible reductions of the program: one in which John
gets the cake and Mary is disappointed, and one in which Mary gets cake and John
is disappointed.
\def\exampleprograma{\red{\ensuremath{%
      \cut{x}(\recv{x}{y}\john \mid \recv{x}{z}\mary \mid
      \send{x}{\cake}\send{x}{\nocake}\ptis)
    }}}
\def\exampleresultaa{\red{\ensuremath{%
      \cut{x}(\subst{\john}{\cake}{y} \mid \subst{\mary}{\nocake}{z} \mid \ptis)
    }}}
\def\exampleresultab{\red{\ensuremath{%
      \cut{x}(\subst{\john}{\nocake}{y} \mid \subst{\mary}{\cake}{z} \mid \ptis)
    }}}
\def\examplereductiona{%
  \begin{tikzpicture}
    \node (program) at (0,0) {$\exampleprograma\quad$};
    \node[above=1cm, right=1cm, at=(program.east)] (resulta)
    {$\!\!^\star\quad\exampleresultaa$};
    \node[below=1cm, right=1cm, at=(program.east)] (resultb)
    {$\!\!^\star\quad\exampleresultab$};
    \draw[->] (program.east) to [out=045,in=180] (resulta.west);
    \draw[->] (program.east) to [out=315,in=180] (resultb.west);
  \end{tikzpicture}
}
\[\examplereductiona\]
Races show up in any client/server system where clients compete for limited
server resources. It is therefore important that any concurrent programming
language allows us to write them.
\\
It should be obvious from the above example that the $\pi$-calculus is up to the
task of modeling such programs. However, it can also model some undesirable
programs, programs which `go wrong'. An example of such a program is the
following scenario:
\begin{quote}
  John managed to order the last slice of cake from the p\^atisserie. However,
  Mary \emph{really} wants it, and offers him some money for it. John agrees,
  but sadly there is no trust between the two. Mary demands to get the cake
  first, before she gives John the money. John demands to get the money first,
  before he gives Mary the cake.
\end{quote}
This scenario is a classic example of a deadlock, and it is modeled in the
$\pi$-calculus by the program below, given that \john\ and \mary\ are processes
representing John and Mary, respectively, \cake\ is a channel over which
\john\ will send a slice of cake, and \money\ is a channel over which \mary\ %
will send money.
\def\exampleprogramb{\red{\ensuremath{%
      \cut{x}(\recv{x}{y}\send{x}{\cake}\john \mid \recv{x}{z}\send{x}{\money}\mary)
    }}}
\[\exampleprogramb\]
The program is stuck---John is refusing to send the cake until he receives money
from Mary, and Mary is refusing to send the money until John sends the cake, so
nothing will actually happen.
It `goes wrong', in the sense that a deadlock is unlikely to be the intended
behaviour of a program.

Session types, a formalism proposed by~\cite{honda1993}, can provide static
guarantees that concurrent processes respect communication protocols, by
specifying the expected structure of communications among processes.
Recently, work by~\cite{caires2010} and~\cite{wadler2012} has yielded tight
correspondences between session typed $\pi$-calculi and intuitionistic and
classical linear logic~\cite{girard1987}, respectively.
These correspondences are tight in the following sense: not only do they
interpret session types as linear propositions, but they also show a
correspondence between reduction in the $\pi$-calculus and cut elimination in
linear logic.
Furthermore, by the very nature of their correspondence with linear logic,
programs in these calculi are guaranteed to be free from deadlocks.
Unfortunately, they are also free from \emph{races}.

In this paper, we introduce \nodcap\ (Nodcap), an extension of the type system
CP~\cite{wadler2012} which is more permissive, and permits programs with races,
without losing the tight correspondence with classical linear logic or the
guarantee of deadlock.
The paper is structured as follows. In the next section, we introduce the
relevant variant of the $\pi$-calculus and its type system CP~\cite{wadler2012}.
Then, we introduce the type system \nodcap.
Following this, we and extend the proof of cut elimination for CP to cover
\nodcap.
Last, we discuss the types of concurrency that \nodcap\ allows us to capture.

The type system and cut elimination procedure presented in the remainder of this
paper have been formalised using the Agda proof assistent~\cite{norell2009}, and
the code is available on GitHub.\footnote{
  \red{Insert GitHub URL here.}
}

\section{Background}
In this section, we will discuss a rudimentary subset of the session-typed
process calculus CP~\cite{wadler2012}, which we will refer to as RCP.
Under the correspondence with linear logic, RCP corresponds to multiplicative
additive linear logic, often referred to as MALL.
The process calculus used by RCP is a variant of the
$\pi$-calculus~\cite{milner1992}. Processes in RCP are defined by the following
grammar:
\[
  \begin{aligned}
    \red{P},\:&\red{Q},\red{R} ::=\\
    & \red{\link{x}{y}}           &&\text{link}
    &&\red{\cut{x}(P \mid Q)}     &&\text{parallel composition}\\
    & \red{\send{x}{y}(P \mid Q)} &&\text{output}
    &&\red{\recv{x}{y}P}          &&\text{input}\\
    & \red{\inl{x}P}              &&\text{left selection}
    &&\red{\inr{x}P}              &&\text{right selection}\\
    & \red{\case{x}{P}{Q}}        &&\text{choice}
    &&\red{\case{x}{}{}}          &&\text{empty choice}\\
    & \red{\send{x}{}0}           &&\text{empty output}
    &&\red{\recv{x}{}P}           &&\text{empty input}\\
  \end{aligned}
\]
The construct $\link{x}{y}$ links two channels~\cite{sangiorgi1996,boreale1998},
forwarding messages received on $x$ to $y$ and vice versa.
%
The construct $\cut{x}{(P \mid Q)}$ creates a new channel $x$, and composes two
processes, which communicate on $x$, in parallel.
Therefore, in $\cut{x}{(P \mid Q)}$ the name $x$ is bound in both $P$ and $Q$.
%
Round brackets are used for input, square brackets for output.
We use bound output~\cite{sangiorgi1996}---this means that unlike in the
$\pi$-calculus, both input and output bind a new name.
In $\recv{x}{y}P$ the new name $y$ is bound in $P$.
In $\send{x}{y}{(P \mid Q)}$, the new name $y$ is only bound in $P$, not in $Q$.

Processes in RCP are typed using session types which correspond to the
multiplicative and additive connectives from linear logic. These are defined
using the following grammar:
\[
  \begin{aligned}
    \blue{A},\:&\blue{B},\blue{C} ::=\\
    & \tm{A \tens B} &&\text{`tensor', independent sessions A and B}
    &&\tm{\one}      &&\text{unit for \tens}\\
    & \tm{A \parr B} &&\text{`par', possibly dependent sessions A and B}
    &&\tm{\bot}      &&\text{unit for \parr}\\
    & \tm{A \plus B} &&\text{`plus', select session A or B}
    &&\tm{\nil}      &&\text{unit for \plus}\\
    & \tm{A \with B} &&\text{`with', offer session A or B}
    &&\tm{\top}      &&\text{unit for \with}
  \end{aligned}
\]
The multiplicatives ($\tens$, $\parr$) deal with dependence and independence.
A channel of type $A \tens B$ represents a pair of channels which communicate
with two \emph{indepentent} processes---that is to say, two processes who share
no channels.
A channel of type $A \parr B$ represents a pair of channels which are used
within a single process. This means that their interactions can depend on one
another---i.e.\ the interaction of type $B$ could depend on the result of the
interaction of type $A$, or vice versa.
The multiplicative units ($\one$, $\bot$) follow the same pattern.
A channel of type $\one$ communicates with a process which has no other
channels, and therefore can do nothing.
A channel of type $\bot$ communicates with a process which is not further
restricted.

The additives ($\plus$, $\with$) deal with choice---making choices and offering
them.
A process communicating over a channel of type $A \plus B$ can select either an
interaction of type $A$ or one of type $B$.
A process communicating over a channel of type $A \with B$ has to be prepared to
offer an interaction either of type $A$ or of type $B$.
The additive units ($\nil$, $\top$) follow the same pattern, except with nullary
instead of binary choices. That is to say, along a channel of type $\nil$, one
has to select one of \emph{zero} options---which is, of course, impossible.
Therefore, when communicating over a channel of type $\top$, one has to be
prepared to offer any of \emph{zero} different interactions---which is, of
course, trivial.

Duality plays a crucial role in linear logic and session types. It ensures that
a process offering a choice on one end of a channel is matched with a process
which accepts a choice on the other. It is also crucial to deadlock freedom, as
it ensures that a process which uses communication on $x$ to decide what to send
on $y$ is communicating with two independent processes on $x$ and $y$,
preventing circular dependencies. Each type $A$ has a dual, defined as follows:
\[
  \begin{array}{rclcrcl}
    \tm{( A \tens B )^\bot} &=& \tm{A^\bot \parr B^\bot}&&
    \tm{\one^\bot}          &=& \tm{\bot}\\
    \tm{( A \parr B )^\bot} &=& \tm{A^\bot \parr B^\bot}&&
    \tm{\bot^\bot}          &=& \tm{\one}\\
    \tm{( A \plus B )^\bot} &=& \tm{A^\bot \with B^\bot}&&
    \tm{\nil^\bot}          &=& \tm{\top}\\
    \tm{( A \with B )^\bot} &=& \tm{A^\bot \plus B^\bot}&&
    \tm{\top^\bot}          &=& \tm{\nil}
  \end{array}
\]
Environments associate names with types. They are defined as follows:
\[
  \blue{\Gamma},\blue{\Delta},\blue{\Theta} ::=
  \tm[x_1]{A_1},\tm[x_2]{A_2},\dots,\tm[x_n]{A_n}
\]
Note that each name in an environment should be unique. This means that $x_i
\neq x_j$ wherever $i \neq j$, and that environments $\Gamma$ and $\Delta$ can
only be combined if $\text{fv}(\Gamma) \cap \text{fv}(\Delta) = \emptyset$.

Judgements indicate that a process $P$ communicates along each channels $x_i$
following the communication protocol specified by $A_i$. They are defined as
follows:
\[
  \seq[{ P }]{ \tm[x_1]{A_1},\tm[x_2]{A_2},\dots,\tm[x_n]{A_n} }
\]
The rules for assigning session types to processes in RCP are shown in
Figure~\ref{fig:cp}.
%
\input{fig-cp}

\noindent
Let's briefly go back to our example of a deadlock:
\[\exampleprogramb\]
As CP and RCP are deadlock free, it should be obvious that there is no valid type
assignment for this program.
There are, however, two close variants which are typable.
These correspond to the programs in which John is given the power to decide
which of the goods is sent first, and that in which Mary is given that power.
The first of these is modeled in RCP by the program below, given that $\john$ is
a process which will receive money and send out cake, in any order, $\mary$ is a
process which will receive cake, $\money$ is a process which will send money
\emph{and} the type of money, and $\plato$ is the type of $\cake$.
\begin{prooftree}
  \AXC{$\seq[{\john}]{\Gamma, \tm[y]{\money^\bot}, \tm[x]{\plato}}$}
  \SYM{\parr}
  \UIC{$\seq[{\recv{x}{y}\john}]{\Gamma, \tm[x]{\money^\bot \parr \plato}}$}
  \AXC{$\seq[{\money}]{\Delta, \tm[z]{\money}}$}
  \AXC{$\seq[{\mary}]{\Theta, \tm[x]{\plato^\bot}}$}
  \SYM{\tens}
  \BIC{$\seq[{\send{x}{z}(\money \mid \mary)}]{\Delta, \tm[x]{\money \tens \plato^\bot}}$}
  \NOM{Cut}
  \BIC{$\seq[{\cut{x}(\recv{x}{y}\john \mid \send{x}{z}(\money \mid \mary))}]{\Gamma, \Delta, \Theta}$}
\end{prooftree}
Note that the typing rule for $\tens$ forces Mary, who in our example sends
money to John and receives cake in return, to be represented by two
\emph{independent} processes $\money$ and $\mary$, one of which sends money, and
the other receives cake.

It should be noted that there is a third variant of the deadlocked process which
is harmless but \emph{not} well-typed in RCP.
This is the variant in which \emph{both} John and Mary are powerless to decide
which of the goods is sent first. This would be equivalent to assigning the
types $\money^\bot \tens \plato$ and $\money \tens \plato^\bot$ to John and
Mary, respectively.
As shown by~\cite{atkey2016}, such a program becomes typable in a version of CP
extended with \textsc{Mix}, or equivalently in a version of CP extended with
some atomic process $P_{\tens}{}_{\parr}$ of the type $A \tens B \limp A \parr B$
(where $A \limp B$ is defined as $A^\bot \parr B$).

Under the correspondence with linear logic, communication in RCP is identified
with the elimination of the \textsc{Cut} rule. We can show that any application
of the \textsc{Cut} rule can be eliminated.
\begin{quote}
  \textit{Proof sketch.}
  Given a program with one or more cuts, we pick any such application $\cut{x}(P
  \mid Q)$ such that $P$ and $Q$ are free from cuts.
  There are three cases:
  \begin{enumerate}
  \item
    If either $P$ or $Q$ is a link $\link{x}{y}$ we can eliminate the cut
    immediately, e.g.\ %
    \begin{center}
      \begin{prooftree*}
        \AXC{}
        \NOM{Ax}
        \UIC{$\seq[{ \link{y}{x} }]{ \tm[y]{A^\bot}, \tm[x]{A} }$}
        \AXC{$\seq[{ P }]{ \Gamma, \tm[x]{A^\bot} }$}
        \NOM{Cut}
        \BIC{$\seq[{ \cut{x}(\link{y}{x} \mid P) }]{ \Gamma, \tm[y]{A^\bot} }$}
      \end{prooftree*}
      $\Longrightarrow$
      \begin{prooftree*}
        \AXC{$\seq[{ \subst{P}{y}{x} }]{ \Gamma, \tm[y]{A^\bot} }$}
      \end{prooftree*}
    \end{center}
  \item
    If the last rules applied in $P$ and $Q$ both introduced the top-level
    connective in the type of $x$, then we apply any of the principal cut
    reductions, seen in Figure~\ref{fig:cp-cut-prin}. These replace a cut with
    one or more cuts on channels with a \emph{stricly smaller} type.
  \item
    Otherwise, we apply one of the commutative conversions for \textsc{Cut},
    seen in Figure~\ref{fig:cp-cut-cc}.\footnote{
      In the interest of space, we are presenting the commutative conversions on
      terms alone. For the full versions, which act on proofs, see the
      appendices (insert reference here).
    }
    These move the application of \textsc{Cut} further into the term.
  \end{enumerate}
  We iteratively apply this procedure until there are no more applications of
  \textsc{Cut} left in the program.
\end{quote}
The proof for cut elimination above is entirely satisfactory from a logical
perspective, but deviates slightly from the proof given by~\cite{wadler2012},
in that it reduces cuts under an arbitrary prefix.
To recover the version described in~\cite{wadler2012}, restrict the selection
of cuts to reduce to those under a prefix of cuts only, and add two commutative
conversions which commute two cuts. This changes definition of normal form
``free from cuts'' to ``free from cuts at the top-level''.
%
\input{fig-cp-cut-prin}
\input{fig-cp-cut-cc}


\section{Main contribution}
In the previous section, we have seen RCP, and briefly discussed how it prevents
deadlocks. Let's now go back to our \emph{other} example, and see how RCP
prevents races:
\[\examplereductiona\]
Races occur when more than two processes attempt to communicate simultaneously
over the same channel.
However, the \textsc{Cut} rule only allows \emph{exactly two} processes to
communicate over a channel, and only if they use the channel dually:
\begin{prooftree}
  \AXC{$\seq[{P}]{\Gamma,\tm[x]{A}}$}
  \AXC{$\seq[{Q}]{\Delta,\tm[x]{A^\bot}}$}
  \NOM{Cut}
  \BIC{$\seq[{\cut{x}(P \mid Q)}]{\Gamma,\Delta}$}
\end{prooftree}
The race in our example is completely benign. Therefore, we would like to extend
RCP to also assign a type to this race. This essentially boils down to the
following question---what typing constructs do we need to complete the following
proof:\footnote{%
  It should be noted that $\cake$ and $\nocake$ are both considered to be of the
  type \plato, with $\nocake$ being the vastly more disappointing value of the
  cake type.
}
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tm[y]{\plato^\bot} }$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tm[z]{\plato^\bot} }$}
  \AXC{$\seq[{ \ptis }]{ \Theta, \tm[\cake]{\plato}, \tm[\nocake]{\plato} }$}
  \noLine\TIC{$\vdots$}\noLine
  \UIC{$\seq[{ \exampleprograma }]{ \Gamma, \Delta, \Theta }$}
\end{prooftree}
Ideally, we would use a regular \textsc{Cut} to introduce the channel $x$ in
this proof. We can do this if we group John and Mary on one side of the
\textsc{Cut}, and put the p\^atisserie on the other side. This seems
reasonable---John and Mary both try to get a cake, and the p\^atisserie offers
to try and provide a cake twice.
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tm[y]{\plato^\bot} }$}
  \noLine\UIC{$\vdots$}\noLine
  \AXC{$\seq[{ \mary }]{ \Delta, \tm[z]{\plato^\bot} }$}
  \noLine\UIC{$\vdots$}\noLine
  \BIC{$\seq[{ (\recv{x}{y}\john \mid \recv{x}{z}\mary) }]{ \Gamma, \Delta, \tm[x]{???^\bot} }$}
  \AXC{$\seq[{ \ptis }]{ \Theta, \tm[\cake]{\plato}, \tm[\nocake]{\plato} }$}
  \noLine\UIC{$\vdots$}\noLine
  \UIC{$\seq[{ \send{x}{\cake}\send{x}{\nocake}\ptis }]{\Theta, \tm[x]{???} }$}
  \NOM{Cut}
  \BIC{$\seq[{ \exampleprograma }]{ \Gamma, \Delta, \Theta }$}
\end{prooftree}
Furthermore, the actions of John and Mary are completely independent, whereas
for the p\^atisserie its actions are order dependent---it will ship a slice of
cake first, and only then ship disappointment.
This makes it seem like we could fill in the $???$ with the type
$\plato^\bot \parr \plato^\bot$. However, this would have two problems:
\def\exampleprogramc{\red{\ensuremath{%
      \cut{x}(\send{x}{y}(\john \mid \mary) \mid \recv{x}{z}\ptis)
    }}}%
\begin{enumerate}
\item
  We would implement our ``race'' with the program below, instead of the program
  we described in $\pi$-calculus:
  \begin{prooftree}
    \AXC{$\seq[{ \john }]{ \Gamma, \tm[y]{\plato^\bot} }$}
    \AXC{$\seq[{ \mary }]{ \Delta, \tm[x]{\plato^\bot} }$}
    \SYM{\tens}
    \BIC{$\seq[{ \send{x}{y}(\john \mid \mary) }]{ \Gamma, \Delta,
        \tm[x]{\plato^\bot \tens \plato^\bot} }$}
    \AXC{$\seq[{ \ptis }]{ \Theta, \tm[x]{\plato}, \tm[z]{\plato} }$}
    \SYM{\parr}
    \UIC{$\seq[{ \recv{z}{x}\ptis }]{ \Theta, \tm[x]{\plato \parr \plato} }$}
    \NOM{Cut}
    \BIC{$\seq[{ \exampleprogramc }]{ \Gamma, \Delta, \Theta }$}
  \end{prooftree}
\item
  Consequently, we would be giving the choice of who receives the cake to the
  p\^atisserie. This no longer accurately models our example, where the choice
  of who receives the cake is non-deterministic, and depends on factors outside
  of the p\^atisserie's control---i.e.\ on who happens to place their order first.
\end{enumerate}
Thus, we add a new dual pair of connectives to RCP---$\give[n]{A}$ (give) and
$\take[n]{A}$ (take). These make the same dependence/independence distinction
that par and tensor make, but have a non-deterministic reduction behaviour.
They are labeled with an index $n$, because we would like to have the ability to
group more than two server or client interactions together, while ensuring that
there are sufficient server resources for every client, and sufficent clients
for each server.

In the following two sections, we will look at the two sides of the \textsc{Cut}
in our incomplete proof, describe the rules we add for `give' and `take', and
show how they allow us to complete our proof.
The complete set of rules added in \nodcap\ can be found in
Figure~\ref{fig:nodcap}.


\subsection*{Servers and contraction}
Our intepretation of a server is any process which offers up a sequence of
interactions which are dependent on one another. Examples are our p\^atisserie,
who gives out cake until it runs out, a ticket server which hands out numbered
tickets in order, etc.
We introduce two new rules to construct servers. The first, $\give[1]{}$, marks
a channel as a server interaction. It does this by sending the channel $y$
across a channel $x$:\footnote{%
  Ultimately, it does not matter whether this rule is implemented with a send or
  a receive action. All that matters is that $\give[1]{}$ and $\take[1]{}$
  introduce dual operations---a send and a receive.
}
\begin{prooftree}
  \AXC{$\seq[{P}]{ \Gamma , \tm[y]{A} }$}
  \SYM{\give[1]{}}
  \UIC{$\seq[{ \give{\send{x}{y}}P }]{ \Gamma , \tm[x]{\give[1]{A}} }$}
\end{prooftree}
The second rule, \textsc{Cont}, enables the contraction of server interactions.
This enables us to construct a server which has multiple interactions of the
same type across the same channel $x$: 
\begin{prooftree}
  \AXC{$\seq[{ P }]{ \Gamma , \tm[x]{\give[m]{A}} , \tm[y]{\give[n]{A}} }$}
  \NOM{Cont}
  \UIC{$\seq[{ \subst{P}{x}{y} }]{ \Gamma , \tm[x]{\give[m+n]{A}} }$}
\end{prooftree}
Using these rules, we can derive the right-hand side of our proof by marking
each of the p\^atisserie's interactions as server interactions, and then
contracting them:
\begin{prooftree}
  \AXC{$\seq[{ \ptis }]{ \Theta, \tm[\cake]{\plato}, \tm[\nocake]{\plato} }$}
  \SYM{\give[1]{}}
  \UIC{$\seq[{ \give{\send{x'}{\nocake}}\ptis }]{
      \Theta, \tm[\cake]{\plato}, \tm[x']{\give[1]{\plato}} }$}
  \SYM{\give[1]{}}
  \UIC{$\seq[{ \give{\send{x}{\cake}}\give{\send{x'}{\nocake}}\ptis }]{
      \Theta, \tm[x]{\give[1]{\plato}}, \tm[x']{\give[1]{\plato}} }$}
  \NOM{Contract}
  \UIC{$\seq[{ \give{\send{x}{\cake}}\give{\send{x}{\nocake}}\ptis }]{
      \Theta, \tm[x]{\give[2]{\plato}} }$}
\end{prooftree}


\subsection*{Clients and pooling}
The dual of a server is not a client, but a pool of clients---a number of
independent processes which each wish to have an interaction with the
server. Examples are our processes John and Mary, customers to ticket servers,
etc. We introduce two new rules---one to construct clients and one to
\emph{pool} them together. The first, $\take[1]{}$, marks an interaction as a
client interaction. It does this by receiving the channel $y$, across which the
actual interaction will take place, over some shared channel $x$:
\begin{prooftree}
  \AXC{$\seq[{ P }]{ \Gamma , \tm[y]{A} }$}
  \SYM{\take[1]{}}
  \UIC{$\seq[{ \take{\recv{x}{y}}P }]{ \Gamma , \tm[x]{\take[1]{A}} }$}
\end{prooftree}
The second rule, \textsc{Pool}, enables us to pool together clients. This is
implemented using a $\pi$-calculus parallel composition, which puts together two
client pools, in which each client attempts to interact across $x$:
\begin{prooftree}
  \AXC{$\seq[{ P }]{ \Gamma , \tm[x]{\take[m]{A}} }$}
  \AXC{$\seq[{ Q }]{ \Delta , \tm[x]{\take[n]{A}} }$}
  \NOM{Pool}
  \BIC{$\seq[{ (P \mid Q) }]{ \Gamma , \Delta , \tm[x]{\take[m+n]{A}} }$}
\end{prooftree}
Using these rules, we can derive the left-hand side of our proof by marking John
and Mary as clients looking for cake, and pooling them together:
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tm[y]{\plato^\bot} }$}
  \SYM{\take[1]{}}
  \UIC{$\seq[{ \take{\recv{x}{y}}\john }]{ \Gamma, \tm[x]{\take[1]{\plato^\bot}} }$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tm[z]{\plato^\bot} }$}
  \SYM{\take[1]{}}
  \UIC{$\seq[{ \take{\recv{x}{z}}\mary }]{ \Delta, \tm[x]{\take[1]{\plato^\bot}} }$}
  \SYM{}
  \BIC{$\seq[{ (\take{\recv{x}{y}}\john \mid \take{\recv{x}{z}}\mary) }]{
      \Gamma, \Delta, \tm[x]{\take[2]{\plato^\bot}} }$}
\end{prooftree}
Thus, we complete the derivation of our example.
%
\input{fig-nodcap}


\subsection*{Non-deterministic communication and cut elimination}
All that remains is to show that the proof of cut elimination for RCP can be
extended to cover \nodcap. In order to show this, we need to do two things.
We need to
\begin{enumerate}
\item
  give \emph{four} new commutative conversion, in order to show that
  \textsc{Cut} commutes with the four new proof rules we have introduced; and
\item
  give \emph{one} new principal cut reduction, to show that we can reduce a cut
  on a channel of type $\give[n]{A}$/$\take[n]{A}$ to a number of smaller cuts.
\end{enumerate}
The commutative conversions are shown in Figure~\ref{fig:nodcap-cut-perm}.
%
\input{fig-nodcap-cut-perm}
%
All that remains is to give a reduction rule for a cut between a server and a
client pool:  
\begin{prooftree}
  \AXC{$\seq[{ P }]{ \Gamma, \tm[x]{\give[n]{A^\bot}}}$}
  \AXC{$\seq[{ R }]{ \Delta, \tm[x]{\take[n]{A}} }$}
  \NOM{Cut}
  \BIC{$\seq[{ \cut{x}(P \mid R) }]{ \Gamma, \Delta }$}
\end{prooftree}
In order to do this, we introduce two new admissible rules---server expansion,
and client interleaving:
\begin{center}
  \begin{scprooftree*}[0.90]
    \AXC{$\seq[{ P }]{ \Gamma, \tm[x]{\give[n]{A}} }$}
    \NOM{Exp}
    \UIC{$\seq[{ \expn{x}{x_1 \cdots x_n}P }]{ \Gamma, \tm[x_1]{A} \cdots \tm[x_n]{A} }$} 
  \end{scprooftree*}%
  \begin{scprooftree*}[0.90]
    \AXC{$\seq[{ P }]{ \Gamma, \tm[x_1]{A^\bot} \cdots \tm[x_n]{A^\bot} }$} 
    \AXC{$\seq[{ Q }]{ \Delta, \tm[y]{\take[n]{A}} }$}
    \NOM{Int}
    \BIC{$\seq[{ \intl{y}{x_1 \cdots x_n}(P \mid Q) }]{ \Gamma, \Delta }$}
  \end{scprooftree*}
\end{center}
We can compose these rules to eliminate the above cut. However, this has simply
moved the problem. How do we eliminate applications of \textsc{Exp} and
\textsc{Int}? This involves two more proofs with the exact same structure as
that of cut elimination.

The principal eliminations and commutative conversions for \textsc{Exp} are
shown in Figure~\ref{fig:nodcap-expn}. When we put these together, we see that
the operation $\expn{x}{x_1 \dots x_n}P$ strips all the applications of
$\give[1]{}$ and \textsc{Cont} from a program, and renames the channels which
were marked as server interactions using the names $x_1 \dots x_n$.
% 
\input{fig-nodcap-expn}

The principal eliminations and commutative conversions for \textsc{Int} are
shown in Figure~\ref{fig:nodcap-intl}. When we put these together, we see that
the operation $\intl{x}{y_1 \dots y_n}(P \mid Q)$ joins each interaction $y_i$
with some dual interaction from the client pool. This means that each
interleaving reduces to $n$ cuts, where $n$ is the number of clients. 
% 
\input{fig-nodcap-intl}

\clearpage
\bibliography{main}

%\clearpage
%\appendix
%\input{fig-nodcap-ax}
%\input{fig-nodcap-expn-perm}
%\input{fig-nodcap-expn-perm-2}
%\input{fig-nodcap-intl-perm}
%\input{fig-nodcap-intl-perm-2}

\end{document}

%%% Local Variables:
%%% TeX-master: "main"
%%% End:
