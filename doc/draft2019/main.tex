\documentclass[envcountsame,envcountsect,UKenglish]{llncs}
\usepackage{comment}
\input{preamble}
\mainmatter % start of the contributions
\title{Towards Races in Linear Logic}
\titlerunning{Towards Races in Linear Logic} 
\author{Wen Kokke \and J.\ Garrett Morris \and Philip Wadler}
\tocauthor{Wen Kokke, J.\ Garrett Morris, and Philip Wadler}
\institute{University of Edinburgh, Edinburgh, UK,\\
\email{wen.kokke@ed.ac.uk}}
\begin{document}
\maketitle % typeset the title of the contribution

\begin{abstract}
  Process calculi based in logic, such as \piDILL and CP, provide a
  foundation for deadlock-free concurrent programming, but exclude
  non-determinism and races.
  \dhcp is a reformulation of CP which addresses a fundamental
  shortcoming: the fundamental operator for parallel composition
  from the \pi-calculus does not correspond to any rule
  of linear logic, and therefore not to any term construct in CP.

  We introduce \nodcap, which extends \dhcp with a novel account of non-determinism.
  Our approach draws on bounded linear logic to provide a strongly-typed account of standard process calculus expressions of non-determinism. We show that our extension is expressive enough to capture many uses of non-determinism in untyped calculi, such as non-deterministic choice, while preserving \dhcp's meta-theoretic properties, including deadlock freedom.  
\end{abstract}

\section{Introduction}\label{sec:introduction}

Consider the following scenario:
\begin{quote}
  John and Mary are working from home one morning when they each get a craving
  for a slice of cake. Being denizens of the web, they quickly find the nearest
  store which does home deliveries.
  Unfortunately for them, they both order their cake at the \emph{same} store,
  which has only one slice left. After that, all it can deliver is
  disappointment.
\end{quote}
This is an example of a \emph{race condition}. We can model this scenario in the
\textpi-calculus, where \john, \mary and \store are processes modelling John,
Mary and the store, and \sliceofcake and \nope are channels giving access to a
slice of cake and disappointment, respectively.
This process has two possible outcomes: either John gets the cake, and Mary gets
disappointment, or vice versa. 
\begin{center}
  \(
  \begin{array}{c}
    \tm{(\piPar{%
    \piSend{x}{\sliceofcake}{\piSend{x}{\nope}{\store}}
    }{%
    \piPar{\piRecv{x}{y}{\john}}{\piRecv{x}{z}{\mary}}
    })}
    \\[1ex]
    \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
    \\[1ex]
    \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\john}}{%
    \piSub{\nope}{z}{\mary}}})}
    \quad
    \text{or}
    \quad
    \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\john}}{%
    \piSub{\sliceofcake}{z}{\mary}}})}
  \end{array}
  \)
\end{center}
While John or Mary may not like all of the outcomes, it is the store which is
responsible for implementing the online delivery service, and the store is happy
with either outcome. Thus, the above is an interaction we would like to be able to
model.

Now consider another scenario, which takes place \emph{after} John has already
bought the cake:
\begin{quote}
  Mary is \emph{really} disappointed when she finds out the cake has sold out.
  John, always looking to make some money, offers to sell the slice to her for a
  profit. Mary agrees to engage in a little bit of back-alley cake resale, but
  sadly there is no trust between the two.
  John demands payment first.
  Mary would rather get her slice of cake before she gives John the money.
\end{quote}
This is an example of a \emph{deadlock}. We can also model this scenario in the
\textpi-calculus, where \bill\ is a channel giving access to some adequate
amount of money. 
\begin{center}
  \(
  \begin{array}{c}
    \tm{(\piPar{%
    \piRecv{x}{z}{\piSend{y}{\sliceofcake}{\john}}
    }{%
    \piRecv{y}{w}{\piSend{x}{\bill}{\mary}}
    })}
    \quad
    \centernot\Longrightarrow^{\star}
  \end{array}  
  \)
\end{center}
The above process does not reduce. As both John and Mary would prefer the
exchange to be made, this interaction is desired by \emph{neither}. Thus, the
above is an interaction we would like to exclude.

Session types~\parencite{honda1993} statically guarantee that concurrent
programs, such as those above, respect communication protocols.
Session-typed calculi with logical foundations, such as
\piDILL~\parencite{caires2010} and CP~\parencite{wadler2012}, obtain deadlock freedom as a
result of a close correspondence with logic.
These systems, however, also rule out non-determinism and race conditions. In
this paper, we demonstrate that logic-inspired type systems need not rule out
races.

We present \nodcap (nodcap), an extension of CP with a novel account of
non-determinism and races.
Inspired by bounded linear logic~\parencite{girard1992}, we introduce a form of
shared channels in which the type of a shared channel tracks how many times it
is reused.
As in the untyped $\pi$-calculus, sharing introduces the potential for
non-determinism.
We show that our approach is sufficient to capture practical examples of races,
such as an online store, as well as other formal characterizations of
non-determinism, such as non-deterministic choice.  However, \nodcap does not
lose the meta-theoretical benefits of CP: we show that it enjoys termination and
deadlock-freedom.

An important limitation of our work is that types
in \nodcap explicitly count the potential races on a channel.  It
works fine when there are two or three races, but not $n$ for an
arbitary $n$.  The latter case is obviously important, and we see the
main value of our work as a stepping stone to this more general case.

\nodcp is based on \dhcp~\parencite{kokke2018tlla,kokke2019pacmpl}.
\dhcp is a reformulation of CP which addresses a fundamental
shortcoming: the fundamental operator for parallel composition
from the \pi-calculus does not correspond to any rule
of linear logic, and therefore not to any term construct in CP.

There are two versions of \dhcp: a version with delayed actions,
introduced in \textcite{kokke2019pacmpl}; and a version without
delayed actions, introduced in \textcite{kokke2018tlla}, referred to
as \hcp. In this work, we will base ourselves on the latter.
\textbf{[TODO: Wen to add a sentence to explain why this work is based on
the latter rather than the former, and whether the work would adapt
easily to the former.]}

This paper proceeds as follows.
In \cref{sec:local-choice}, we discuss recent approaches to non-determinism in
logic-inspired session-typed process calculi.
In \cref{sec:cp-revisited}, we introduce a variant of \cp and prove progress and
preservation.
In \cref{sec:cpnd}, we introduce \nodcap.
Finally, in \cref{sec:discussion}, we conclude with a discussion of the work
done in this paper and potential avenues for future work.

\section{Non-determinism, logic, and session types}\label{sec:local-choice}
Recent work extended \piDILL and \cp with operators for non-deterministic
behaviour~\parencite{atkey2016,caires2014,caires2017}.
These extensions all implement an operator known as non-deterministic local
choice. (This operator is written as \tm{P+Q}, but should not be confused with
input-guarded choice from the \textpi-calculus~\parencite{milner1992b}.)
Non-deterministic local choice can be summarised by the following typing and
reduction rules:
\begin{center}
  \begin{prooftree*}
    \AXC{$\seq[{ P }]{ \Gamma }$}
    \AXC{$\seq[{ Q }]{ \Gamma }$}
    \BIC{$\seq[{ P + Q }]{ \Gamma }$}
  \end{prooftree*}
  \hspace*{2cm}
  \(
  \begin{array}{c}
    \reducesto{P + Q}{P}\\
    \reducesto{P + Q}{Q}
  \end{array}
  \)
\end{center}
Local choice introduces non-determinism explicitly, by listing all possible
choices. This is unlike the \textpi-calculus, where non-determinism arises due
to multiple processes communicating on shared channels. We can easily implement
local choice in the \textpi-calculus, using a nullary communication:
\begin{center}
  \(
  \begin{array}{c}
    \tm{( \piPar{\piPar{\piSend{x}{}{\piHalt}}{\piRecv{x}{}{P}}}{\piRecv{x}{}{Q}} )}
    \\[1ex]
    \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
    \\[1ex]
    \tm{( \piPar{P}{\piRecv{x}{}{Q}} )}
    \quad
    \text{or}
    \quad
    \tm{( \piPar{\piRecv{x}{}{P}}{Q} )}
  \end{array}
  \)
\end{center}
In this implementation, the process \tm{\piSend{x}{}{0}} will ``unlock'' either
\tm{P} or \tm{Q}, leaving the other process deadlocked. Or we could use
input-guarded choice:
\begin{center}
  \(
  \tm{( \piPar{\piSend{x}{}{\piHalt}}{( \piRecv{x}{}{P} + \piRecv{x}{}{Q} )} )}
  \)
\end{center}
However, there are many non-deterministic processes in the \textpi-calculus
that are awkward to encode using non-deterministic local choice.
Let us recall our example:
\begin{center}
  \(
  \begin{array}{c}
    \tm{(\piPar{%
    \piSend{x}{\sliceofcake}{\piSend{x}{\nope}{\store}}
    }{%
    \piPar{\piRecv{x}{y}{\john}}{\piRecv{x}{z}{\mary}}
    })}
    \\[1ex]
    \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
    \\[1ex]
    \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\john}}{
    \piSub{\nope}{z}{\mary}}})}
    \quad
    \text{or}
    \quad
    \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\john}}{\piSub{
    \sliceofcake}{z}{\mary}}})}
  \end{array}
  \)
\end{center}
This non-deterministic interaction involves communication. If we wanted to write
down a process which exhibited the same behaviour using non-deterministic local
choice, we would have to write the following process:
\begin{center}
  \(
  \begin{array}{c}
    \tm{
    (\piPar{%
    \piSend{x}{\sliceofcake}{\piSend{y}{\nope}{\store}}
    }{%
    \piPar{\piRecv{x}{z}{\john}}{\piRecv{y}{w}{\mary}}
    })
    +
    (\piPar{%
    \piSend{y}{\sliceofcake}{\piSend{x}{\nope}{\store}}
    }{%
    \piPar{\piRecv{x}{z}{\john}}{\piRecv{y}{w}{\mary}}
    })
    }
    \\[1ex]
    \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
    \\[1ex]
    \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\john}}{\piSub{\nope}{z}{\mary}}})}
    \quad
    \text{or}
    \quad
    \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\john}}{\piSub{\sliceofcake}{z}{\mary}}})}
  \end{array}
  \)
\end{center}
In essence, instead of modelling a non-deterministic interaction, we are
enumerating the resulting deterministic interactions.
This means non-deterministic local choice cannot model non-determinism in the
way the \textpi-calculus does.
%
Enumerating all possible outcomes becomes worse the more processes are involved
in an interaction. Imagine a scenario the following scenario:
\begin{quote}
  Three customers, Alice, John and Mary, have a craving for cake. Should cake be
  sold out, however, well... a doughnut will do. They prepare to order their
  goods via an online store. Unfortunately, they all decide to use the
  same \emph{shockingly} under-stocked store, which has only one slice of cake,
  and a single doughnut. After that, all it can deliver is disappointment.
\end{quote}
We can model this scenario in the \textpi-calculus, where \alice, \john,
\mary, and \store are four processes modelling Alice, John, Mary and the store,
and \sliceofcake, \doughnut, and \nope are three channels giving access to a
slice of cake, a so-so doughnut, and disappointment, respectively.
\begin{center}
  \makebox[\textwidth][c]{\ensuremath{
      \begin{array}{c}
        \tm{(\piPar{%
        \piSend{x}{\sliceofcake}{\piSend{x}{\doughnut}{\piSend{x}{\nope}{\store}}}
        }{%
        \piPar{\piRecv{x}{y}{\alice}}{\piPar{\piRecv{x}{z}{\john}}{\piRecv{x}{w}{\mary}}
        })}}
        \\[1ex]
        \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
        \\[1ex]
        \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\alice}}{\piPar{\piSub{\doughnut}{z}{\john}}{\piSub{\nope}{w}{\mary}}}})}
        \;
        \text{or}
        \;
        \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\alice}}{\piPar{\piSub{\nope}{z}{\john}}{\piSub{\doughnut}{w}{\mary}}}})}
        \\[1ex]
        \tm{(\piPar{\store}{\piPar{\piSub{\doughnut}{y}{\alice}}{\piPar{\piSub{\nope}{z}{\john}}{\piSub{\sliceofcake}{w}{\mary}}}})}
        \;
        \text{or}
        \;
        \tm{(\piPar{\store}{\piPar{\piSub{\doughnut}{y}{\alice}}{\piPar{\piSub{\sliceofcake}{z}{\john}}{\piSub{\nope}{w}{\mary}}}})}
        \\[1ex]
        \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\alice}}{\piPar{\piSub{\sliceofcake}{z}{\john}}{\piSub{\doughnut}{w}{\mary}}}})}
        \;
        \text{or}
        \;
        \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\alice}}{\piPar{\piSub{\doughnut}{z}{\john}}{\piSub{\sliceofcake}{w}{\mary}}}})}
        \\[1ex]
      \end{array}
    }}
\end{center}
With the addition of one process, modelling Alice, we have increased the number
of possible outcomes enormously! In general, the number of outcomes for these
types of scenarios is $n!$, where $n$ is the number of processes. This means
that if we wish to translate any non-deterministic process to one using
non-deterministic local choice, we can expect a factorial growth in the size of
the term.

\section{Hypersequent Classical Processes}\label{sec:cp-revisited}
In this section, we introduce \dhcp~\parencite{kokke2018tlla,kokke2019pacmpl}, the basis for our calculus \nodcap. 

The term language for \hcp is a variant of the \textpi-calculus~\parencite{milner1992b}.
\begin{definition}[Terms]\label{def:hcp-terms}
  \[
    \begin{array}{lrll}
      \tm{P}, \tm{Q}, \tm{R}
        & ::=& \tm{\cpLink{x}{y}}    &\text{link}
      \\&\mid& \tm{\piHalt}          &\text{terminated process}
      \\&\mid& \tm{\piNew{x}{P}}     &\text{name restriction, ``cut''}
      \\&\mid& \tm{( \piPar{P}{Q} )} &\text{parallel composition, ``mix''}
      \\&\mid& \tm{\piSend{x}{y}{P}} &\text{output}
      \\&\mid& \tm{\piRecv{x}{y}{P}} &\text{input}
      \\&\mid& \tm{\piSend{x}{}{P}}  &\text{halt}
      \\&\mid& \tm{\cpWait{x}{}{P}}  &\text{wait}
      \\&\mid& \tm{\cpInl{x}{P}}     &\text{select left choice}
      \\&\mid& \tm{\cpInr{x}{P}}     &\text{select right choice}
      \\&\mid& \tm{\cpCase{x}{P}{Q}} &\text{offer binary choice}
      \\&\mid& \tm{\cpAbsurd{x}}     &\text{offer nullary choice}
    \end{array}
  \]
\end{definition}\noindent
The variables \tm{x}, \tm{y}, \tm{z} and \tm{w} range over channel names. Occasionally, we use $\tm{a}$, $\tm{b}$, and $\tm{c}$ to range over \emph{free} channel names. The construct \tm{\cpLink{x}{y}} links two channels~\parencite{sangiorgi1996,boreale1998}, forwarding messages received on \tm{x} to \tm{y} and vice versa. The construct $\tm{\piNew{x}{P}}$ creates a new channel $\tm{x}$, and the construct $\tm{\piPar{P}{Q}}$ and composes two processes. In \tm{\piRecv{x}{y}{P}} and \tm{\piSend{x}{y}{P}}, round brackets denote input, square brackets denote output. We use bound output~\parencite{sangiorgi1996}, meaning that both input and output bind a new name. 

Terms in \hcp are identified up to structural congruence.
\begin{definition}[Structural congruence]\label{def:hcp-equiv}
  The structural congruence $\equiv$ is the congruence closure over terms which satisfies the following additional axioms:
  \[
    \setlength{\arraycolsep}{3pt}
    \begin{array}{llcllllcll}
        \cpEquivLinkComm
      & \tm{\cpLink{x}{y}}
      & \equiv
      & \tm{\cpLink{y}{x}}
      &
        \hcpEquivNewComm
      & \tm{\piNew{x}{\piNew{y}{P}}}
      & \equiv
      & \tm{\piNew{y}{\piNew{x}{P}}}
      &
      \\
        \hcpEquivMixComm
      & \tm{\piPar{P}{Q}}
      & \equiv
      & \tm{\piPar{Q}{P}}
      &
        \hcpEquivMixAss1
      & \tm{\piPar{P}{( \piPar{Q}{R} )}}
      & \equiv
      & \tm{\piPar{( \piPar{P}{Q} )}{R}}
      &
      \\
        \hcpEquivMixHalt1
      & \tm{\piPar{P}{\piHalt}}
      & \equiv
      & \tm{P}
      &
        \hcpEquivScopeExt1
      & \tm{\piNew{x}{( \piPar{P}{Q} )}}
      & \equiv
      & \tm{\piPar{P}{\piNew{x}{Q}}}
      & \text{if }\notFreeIn{x}{P}
    \end{array}
  \]
\end{definition}
Channels in \hcp are typed using a session type system which is a conservative extension of linear logic.
\begin{definition}[Types]\label{def:cp-types}
  \[
    \begin{array}{lrlllrll}
      \ty{A}, \ty{B}, \ty{C}
        & ::=& \; \ty{A \tens B} &\text{independent channels}
      & &\mid& \; \ty{\one}      &\text{unit for} \; {\tens}
      \\&\mid& \; \ty{A \parr B} &\text{interdependent channels}
      & &\mid& \; \ty{\bot}      &\text{unit for} \; {\parr}
      \\&\mid& \; \ty{A \plus B} &\text{internal choice}
      & &\mid& \; \ty{\nil}      &\text{unit for} \; {\plus}
      \\&\mid& \; \ty{A \with B} &\text{external choice}
      & &\mid& \; \ty{\top}      &\text{unit for} \; {\with}
    \end{array}
  \]  
\end{definition}
Duality plays a crucial role in both linear logic and session types. In \hcp, the two endpoints of a channel are assigned dual types. This ensures that, for instance, whenever a process \emph{sends} across a channel, the process on the other end of that channel is waiting to \emph{receive}. Each type \ty{A} has a dual, written \ty{A^\bot}. Duality (\ty{\cdot^\bot}) is an involutive function on types.
\begin{definition}[Duality]\label{def:cp-negation}
  \[
    \setlength{\arraycolsep}{3pt}
    \begin{array}{lclclcllclclcl}
              \ty{(A \tens B)^\bot} &=& \ty{A^\bot \parr B^\bot}
      &\quad \ty{\one^\bot}        &=& \ty{\bot}
      &\quad \ty{(A \parr B)^\bot} &=& \ty{A^\bot \tens B^\bot}
      &\quad \ty{\bot^\bot}        &=& \ty{\one}
      \\      \ty{(A \plus B)^\bot} &=& \ty{A^\bot \with B^\bot}
      &\quad \ty{\nil^\bot}        &=& \ty{\top}
      &\quad \ty{(A \with B)^\bot} &=& \ty{A^\bot \plus B^\bot}
      &\quad \ty{\top^\bot}        &=& \ty{\nil}
    \end{array}
  \]
\end{definition}
Environments associate channels with types. Names in environments must be unique, and environments \ty{\Gamma} and \ty{\Delta} can only be combined ($\ty{\Gamma}, \ty{\Delta}$) if $\text{fv}(\ty{\Gamma}) \cap \text{fv}(\ty{\Delta}) = \varnothing$. 
\begin{definition}[Environments]\label{def:cp-environments}
  $\ty{\Gamma}, \ty{\Delta}, \ty{\Theta} ::= \tmty{x_1}{A_1}\dots\tmty{x_n}{A_n}$
\end{definition}
\hcp registers parallelism using hyper-environments. A hyper-environment is a multiset of environments. While names within environments must be unique, names may be shared between multiple environments in a hyper-environment. We write $\ty{\mathcal{G} \hsep \mathcal{H}}$ to combine two hyper-environments.
\begin{definition}[Hyper-environments]\label{def:hcp-hyper-environment}
  $\ty{\mathcal{G}}, \ty{\mathcal{H}} ::= \ty{\emptyhypercontext} \, \mid \, \ty{\mathcal{G} \hsep \Gamma}$
\end{definition}
Typing judgements associate processes with collections of typed channels.
\begin{definition}[Typing judgements]\label{def:cp-typing-judgement}
  A typing judgement $\seq[P]{\Gamma_1 \hsep \dots \hsep \Gamma_n}$ denotes that the process $\tm{P}$ consists of $n$ independent, but potentially entangled processes, each of which communicates according to its own protocol $\Gamma_i$. Typing judgements can be constructed using the inference rules below. 
  \\[0.5\baselineskip]
  {Structural rules}
  \begin{center}
    \hcpInfAx
    \hcpInfCut
  \end{center}
  \begin{center}
    \hcpInfMix
    \hcpInfHalt
  \end{center}
  {Logical rules}
  \begin{center}
    \hcpInfBoundTens
    \hcpInfParr
  \end{center}
  \begin{center}
    \hcpInfOne
    \hcpInfBot
  \end{center}
  \begin{center}
    \hcpInfPlus1
    \hcpInfPlus2
  \end{center}
  \begin{center}
    \hcpInfWith
  \end{center}
  \begin{center}
    \hcpInfNil
    \hcpInfTop
  \end{center}
  Furthermore, each logical rule has the side condition that $\tm{x} \not\in \ty{\mathcal{G}}$.
\end{definition}
Reductions relate processes with their reduced forms.
\begin{definition}[Reduction]\label{def:hcp-reduction}
  Reductions are described by the smallest relation $\Longrightarrow$ on process
  terms closed under the rules below:
  \begin{gather*}
    \begin{array}{llcll}
      \hcpRedAxCut1
      & \tm{\cpCut{x}{\cpLink{w}{x}}{P}}
      & \Longrightarrow
      & \tm{\cpSub{w}{x}{P}}
      \\
      \hcpRedBetaTensParr
      & \tm{\cpCut{x}{\piSend{x}{y}{P}}{\piRecv{x}{y}{R}}}
      & \Longrightarrow
      & \tm{\piNew{x}{\piNew{y}{(\piPar{P}{R})}}}
      \\
      \hcpRedBetaOneBot
      & \tm{\cpCut{x}{\piSend{x}{}{P}}{\piRecv{x}{}{Q}}}
      & \Longrightarrow
      & \tm{\piPar{P}{Q}}
      \\
      \hcpRedBetaPlusWith1
      & \tm{\cpCut{x}{\cpInl{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{x}{P}{Q}}
      \\
      \hcpRedBetaPlusWith2
      & \tm{\cpCut{x}{\cpInr{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow
      & \tm{\cpCut{x}{P}{R}}
    \end{array}
  \end{gather*}
  \begin{center}
    \begin{prooftree*}
      \AXC{$\reducesto{P}{P^\prime}$}
      \SYM{\hcpRedGammaNew}
      \UIC{$\reducesto{\piNew{x}{P}}{\piNew{x}{P^\prime}}$}
    \end{prooftree*}
    \begin{prooftree*}
      \AXC{$\reducesto{P}{P^\prime}$}
      \SYM{\hcpRedGammaMix}
      \UIC{$\reducesto{\piPar{P}{Q}}{\piPar{P^\prime}{Q}}$}
    \end{prooftree*}
  \end{center}
  \begin{prooftree}
    \AXC{$\tm{P}\equiv\tm{Q}$}
    \AXC{$\reducesto{Q}{Q^\prime}$}
    \AXC{$\tm{Q^\prime}\equiv\tm{P^\prime}$}
    \SYM{\hcpRedGammaEquiv}
    \TIC{$\reducesto{P}{P^\prime}$}
  \end{prooftree}
\end{definition}

\subsection{Example}
\label{sec:hcp-example}
\hcp uses hyper-sequents to structure communication, and it is this structure which rules out deadlocked interactions. Let us go back to our example of a deadlocked interaction from \cref{sec:introduction}. If we want to type this interaction in \hcp, we run into a problem: to communicate on $\tm{x}$, we need to add name restrictions on $\tm{x}$ and $\tm{y}$, \eg
\begin{center}
  \(
  \tm{\piNew{x}{\piNew{y}{(
        \piPar{\piRecv{x}{z}{\piSend{y}{\sliceofcake}{\john}}}{\piRecv{y}{w}{\piSend{x}{\bill}{\mary}}})}}}.
  \)
\end{center}
However, there is no typing derivation for this term. We illustrate this with the partial typing derivation below. In this derivation, there is no way to proceed, and type the final name restriction. The \textsc{Cut} rule needs a hypersequent separator to eliminate, so that it only ever links up two independent processes, but the bottom-most sequent has none. Furthermore, the two occurrences of $\tm{x}$ appearing in the same environment make it ill-formed.
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tmty{z}{\money^\bot}, \tmty{\sliceofcake}{\cake}}$}
  \SYM{\tens}
  \UIC{$\seq[{ \piSend{y}{\sliceofcake}{\john} }]{ \Gamma, \tmty{z}{\money^\bot}, \tmty{y}{\cake}}$}
  \SYM{\parr}
  \UIC{$\seq[{ \piRecv{x}{z}{\piSend{y}{\sliceofcake}{\john}} }]{ \Gamma, \tmty{x}{\money^\bot}, \tmty{y}{\cake}}$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tmty{\bill}{\money}, \tmty{w}{\cake^\bot} }$}
  \SYM{\tens}
  \UIC{$\seq[{ \piSend{x}{\bill}{\mary} }]{ \Delta, \tmty{x}{\money}, \tmty{w}{\cake^\bot} }$}
  \SYM{\parr}
  \UIC{$\seq[{ \piRecv{y}{w}{\piSend{x}{\bill}{\mary}} }]{ \Delta, \tmty{x}{\money}, \tmty{y}{\cake^\bot} }$}
  \NOM{H-Mix}
  \BIC{$\seq[{
      (\piPar{\piRecv{x}{z}{\piSend{y}{\sliceofcake}{\john}}}{\piRecv{y}{w}{\piSend{x}{\bill}{\mary}}}) }]{
      \Gamma, \tmty{x}{\money^\bot}, \tmty{y}{\cake} \hsep
      \Delta, \tmty{x}{\money}, \tmty{y}{\cake^\bot} }$}
  \NOM{Cut}
  \UIC{$\seq[{
      \piNew{y}{(\piPar{\piRecv{x}{z}{\piSend{y}{\sliceofcake}{\john}}}{\piRecv{y}{w}{\piSend{x}{\bill}{\mary}}})}
    }]{
      \Gamma, \Delta, \tmty{x}{\money^\bot}, \tmty{x}{\money} }$}
\end{prooftree}

\subsection{Metatheory}
\label{sec:hcp-metatheory}
\hcp enjoys subject reduction, termination, and progress~\citep{kokke2018tlla}.
\begin{lemma}[Preservation for $\equiv$]\label{lem:hcp-preservation-equiv}
  If $\tm{P}\equiv\tm{Q}$, then $\seq[P]{\mathcal{G}}$ iff $\seq[Q]{\mathcal{G}}$.
\end{lemma} 
\begin{proof}
  By induction on the derivation of $\tm{P}\equiv\tm{Q}$.
\end{proof}
\begin{theorem}[Preservation]\label{thm:hcp-preservation}
  If $\seq[P]{\mathcal{G}}$ and $\reducesto{P}{Q}$, then $\seq[Q]{\mathcal{G}}$.
\end{theorem} 
\begin{proof}
  By induction on the derivation of $\reducesto{P}{Q}$.
\end{proof}
\begin{definition}[Actions]
  A process $\tm{P}$ acts on $\tm{x}$ whenever $\tm{x}$ is free in the outermost
  term constructor of $\tm{P}$, \eg $\tm{\piSend{x}{y}{P}}$ acts on $\tm{x}$
  but not on $\tm{y}$, and $\tm{\cpLink{x}{y}}$ acts on both $\tm{x}$ and $\tm{y}$.
  A process $\tm{P}$ is an action if it acts on some channel $\tm{x}$.
\end{definition}
\begin{definition}[Canonical forms]\label{def:hcp-canonical-forms}
  A process $\tm{P}$ is in canonical form if
  \[
  \tm{P} \equiv \tm{\piNew{x_1}{\dots\piNew{x_n}{(P_1 \mid \dots \mid P_{n+m+1})}}},
  \]
  such that: no process $\tm{P_i}$ is a cut or a mix; no process $\tm{P_i}$ is a link acting on a bound channel $\tm{x_i}$; and no two processes $\tm{P_i}$ and $\tm{P_j}$ are acting on the same bound channel $\tm{x_i}$.
\end{definition}
\begin{corollary}
  If a process $\tm{P}$ is in canonical form, then it is blocked on an external communication.
\end{corollary}
\begin{proof}
  We have
  \[
  \tm{P} \equiv \tm{\piNew{x_1}{\dots\piNew{x_n}{(P_1 \ppar \dots \ppar P_{n+m+1})}}},
  \]
  such that no $\tm{P_i}$ is a cut or a link acting on a bound channel, and no two processes $\tm{P_i}$ and $\tm{P_j}$ are acting on the same bound channel. The prefix of cuts and mixes introduces $n$ channels. Each application of cut requires an application of mix, so the prefix introduces $n+m+1$ processes. Therefore, at least $m+1$ of the processes $\tm{P_i}$ must be acting on a free channel, i.e., blocked on an external communication.
\end{proof}
\begin{theorem}[Progress]\label{thm:hcp-progress}
  If $\seq[P]{\Gamma}$, then either $\tm{P}$ is in canonical form, or there exists a process $\tm{Q}$ such that $\tm{P}\Longrightarrow\tm{Q}$.
\end{theorem} 
\begin{proof}
  We consider the maximum prefix of cuts and mixes of $\tm{P}$ such that
  \[
  \tm{P} \equiv \tm{\piNew{x_1}{\dots\piNew{x_n}{(P_1 \ppar \dots \ppar P_{n+m+1})}}},
  \]
  and no $\tm{P_i}$ is a cut. If any process $\tm{P_i}$ is a link, we reduce by $(\cpLink{}{})$. If any two processes $\tm{P_i}$ and $\tm{P_j}$ are acting on the same channel $\tm{x_i}$, we rewrite by $\equiv$ and reduce by the appropriate $\beta$-rule. Otherwise, $\tm{P}$ is in canonical form.
\end{proof}
\begin{theorem}[Termination]\label{thm:hcp-termination}
  If $\seq[P]{\mathcal{G}}$, then there are no infinite $\Longrightarrow$-reduction sequences.
\end{theorem} 
\begin{proof}
  Every reduction reduces a single cut to zero, one or two cuts. However, each of these cuts is smaller, measured in the size of the cut formula. Furthermore, each instance of the structural congruence preserves the size of the cut. Therefore, there cannot be an infinite $\Longrightarrow$-reduction sequence.
\end{proof}

\section{Shared Channels and Non-Determinism}\label{sec:cpnd}
In this section, we will discuss our main contribution: an extension of \hcp which allows for races while still excluding deadlocks. We have seen in \cref{sec:hcp-example} how \hcp excludes deadlocks, but how exactly does \hcp exclude races? Let us return to our example from \cref{sec:introduction}, to the interaction between John, Mary and the store. 
\begin{center}
  \(
  \begin{array}{c}
    \tm{(\piPar{%
    \piSend{x}{\sliceofcake}{\piSend{x}{\nope}{\store}}
    }{%
    \piPar{\piRecv{x}{y}{\john}}{\piRecv{x}{z}{\mary}}
    })}
    \\[1ex]
    \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
    \\[1ex]
    \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\john}}{\piSub{\nope}{z}{\mary}}})}
    \quad
    \text{or}
    \quad
    \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\john}}{\piSub{\sliceofcake}{z}{\mary}}})}
  \end{array}
  \)
\end{center}
Races occur when more than two processes attempt to communicate simultaneously over the \emph{same} channel. However, the \textsc{Cut} rule of \hcp requires that \emph{exactly two} processes communicate over each channel:
\begin{center}
  \hcpInfCut
\end{center}
We could attempt to write down a protocol for our example, stating that the store
has a pair of channels $\tm{x}, \tm{y} : \ty{\cake}$ with which it communicates
with John and Mary, taking \cake to be the type of interactions in which cake
\emph{may} be obtained, i.e.\ of both \sliceofcake and \nope, and state that the
store communicates with John \emph{and} Mary over a channel of type \ty{\cake
  \parr \cake}.
However, this \emph{only} models interactions such as the following:
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tmty{x}{\cake^\bot} }$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tmty{y}{\cake^\bot} }$}
  \NOM{H-Mix}
  \BIC{$\seq[{ (\piPar{\john}{\mary}) }]{
      \Gamma, \tmty{x}{\cake^\bot} \hsep \Delta, \tmty{x}{\cake^\bot} }$}
  \SYM{\tens}
  \UIC{$\seq[{ \cpSend{y}{x}{\john}{\mary} }]{
      \Gamma, \Delta, \tmty{y}{\cake^\bot \tens \cake^\bot} }$}
  \AXC{$\seq[{ \store }]{ \Theta, \tmty{x}{\cake}, \tmty{y}{\cake} }$}
  \SYM{\parr}
  \UIC{$\seq[{ \cpRecv{y}{x}{\store} }]{
      \Theta, \tmty{y}{\cake \parr \cake} }$}
  \NOM{H-Mix}
  \BIC{$\seq[{ (\piPar{\cpSend{y}{x}{\john}{\mary}}{\cpRecv{y}{x}{\store}}) }]{
      \Gamma, \Delta, \tmty{y}{\cake^\bot \tens \cake^\bot}
      \hsep
      \Theta, \tmty{y}{\cake \parr \cake} }$}
  \NOM{Cut}
  \UIC{$\seq[{ \cpCut{y}{\cpSend{y}{x}{\john}{\mary}}{\cpRecv{y}{x}{\store}} }]{
      \Gamma, \Delta, \Theta }$}
\end{prooftree}
In this interaction, John will get whatever the store decides to send on \tm{x}, and Mary will get whatever the store decides to send on \tm{y}. This means that this interactions gives the choice of who receives what \emph{to the store}. This is not an accurate model of our original example, where the choice of who receives the cake is non-deterministic and depends on factors outside of any of the participants' control!

Modelling racy behaviour, such as that in our example, is essential to describing the interactions that take place in realistic concurrent systems. We would like to extend \hcp to allow such races in a way which mirrors the way in which the \textpi-calculus handles non-determinism. Let us return to our example:
\begin{center}
  \(
  \tm{(\piPar{%
      \piSend{x}{\sliceofcake}{\piSend{x}{\nope}{\store}}
    }{%
      \piPar{\piRecv{x}{y}{\john}}{\piRecv{x}{z}{\mary}}
    })}
  \)
\end{center}
In this interaction, we see that the channel \tm{x} is only used only as a way to connect the various clients, John and Mary, to the store. The \emph{real} communication, sending the slice of cake and disappointment, takes places on the channels \tm{\sliceofcake}, \tm{\nope}, \tm{y} and \tm{z}. Inspired by this, we add two new constructs to the term language of \hcp for sending and receiving on a \emph{shared} channel. These actions are marked with a \tm{\star} to distinguish them from ordinary sending and receiving. 
\begin{definition}[Terms]\label{def:nc-terms}
  We extend \cref{def:hcp-terms} with the following constructs:
  \[\!
    \begin{aligned}
      \tm{P}, \tm{Q}, \tm{R}
          ::=& \; \dots
      \\ \mid& \; \tm{\ncCnt{x}{y}{P}} &&\text{client creation}
      \\ \mid& \; \tm{\ncSrv{x}{y}{P}} &&\text{server interaction}
    \end{aligned}
  \]
\end{definition}
As before, round brackets denote input, square brackets denote output. Note that $\tm{\ncCnt{x}{y}{P}}$, much like $\tm{\piSend{x}{y}{P}}$, is a bound output: both client creation and server interaction bind a new name.
The structural congruence, which identifies certain terms, is the same as \cref{def:hcp-equiv}.

In any non-deadlock interaction between a server and some clients, 
there must be \emph{exactly} as many clients as there are server interactions.
Therefore, we add two new \emph{dual} types for client pools and servers, which
track how many clients or server interactions they represent.
\begin{definition}[Types]\label{def:nc-types}
  We extend \cref{def:cp-types} with the following types:
  \[
    \begin{array}{lrll}
      \ty{A}, \ty{B}, \ty{C}
        & ::=& \; \dots
      \\&\mid& \; \ty{\take[n]{A}} &\text{pool of} \; n \; \text{clients}
      \\&\mid& \; \ty{\give[n]{A}} &n \; \text{server interactions}
    \end{array}
  \]  
\end{definition}
The types $\ty{\take[n]{A}}$ and $\ty{\give[n]{A^{\bot}}}$ are dual.
Duality remains an involutive function.

We have to add typing rules to associate our new client and server interactions
with their types. 
The definition for environments will remain unchanged, but we will extend the
definition for the typing judgement.
To determine the new typing rules, we essentially answer the question
``What typing constructs do we need to complete the following proof?''
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tmty{y}{\cake^\bot} }$}
  \noLine\UIC{$\smash{\vdots}\vphantom{\vdash}$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tmty{y'}{\cake^\bot} }$}
  \noLine\UIC{$\smash{\vdots}\vphantom{\vdash}$}
  \AXC{$\seq[{ \store }]{ \Theta, \tmty{z}{\cake}, \tmty{z'}{\cake} }$}
  \noLine\UIC{$\smash{\vdots}\vphantom{\vdash}$}
  \noLine\TIC{$\seq[{
      \cpCut{x}{\ncPool{\ncCnt{x}{y}{\john}}{\ncCnt{x}{y'}{\mary}}}{
        \ncSrv{x}{z}{\ncSrv{x}{z'}{\store}}} }]{
      \Gamma, \Delta, \Theta }$}
\end{prooftree}
The constructs $\tm{\ncCnt{x}{y}{P}}$ and $\tm{\ncSrv{x}{y}{P}}$ introduce a single client or server action, respectively---hence, channels of type $\ty{\take[1]{}}$ and $\ty{\give[1]{}}$. However, when we cut, we want to cut on both interactions simultaneously. We need rules for the \emph{contraction} of shared channel names.

\subsection{Clients and pooling}\label{sec:clients-and-pooling}
A client pool represents a number of independent processes, each wanting to interact with the same server. Examples of such a pool include John and Mary from our example, customers for online stores in general, and any number of processes which interact with a single, centralised server.

We introduce two new rules: one to construct clients, and one to pool them together. The first rule, $(\take[1]{})$, interacts over a channel as a client. It does this by receiving a channel $\tm{y}$ over a \emph{shared} channel $\tm{x}$. The channel $\tm{y}$ is the channel across which the actual interaction will eventually take place. The second rule, $\textsc{Cont}_{!}$, allows us to contract shared channel names with the same type. When used together with \textsc{H-Mix}, this allows us to pool clients together.
\begin{center}
  \ncInfTake1
  \ncInfPool
\end{center}%
Using these rules, we can derive the left-hand side of our proof by marking John and Mary as clients, and pooling them together.
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tmty{y}{\cake^\bot} }$}
  \SYM{(\take[1]{})}
  \UIC{$\seq[{ \ncCnt{x}{y}{\john} }]{ \Gamma, \tmty{y}{\take[1]{\cake^\bot}} }$}

  \AXC{$\seq[{ \mary }]{ \Delta, \tmty{y'}{\cake^\bot} }$}
  \SYM{(\take[1]{})}
  \UIC{$\seq[{ \ncCnt{x'}{y'}{\mary} }]{ \Delta, \tmty{x'}{\take[1]{\cake^\bot}} }$}

  \NOM{H-Mix}
  \BIC{$\seq[{ \ncPool{\ncCnt{x}{y}{\john}}{\ncCnt{x'}{y'}{\mary}} }]{
      \Gamma, \tmty{x}{\take[1]{\cake^\bot}} \hsep
      \Delta, \tmty{x'}{\take[1]{\cake^\bot}} }$}

  \SYM{\textsc{Cont}_{!}}
  \UIC{$\seq[{ \ncPool{\ncCnt{x}{y}{\john}}{\ncCnt{x}{y'}{\mary}} }]{
      \Gamma, \Delta, \tmty{x}{\take[2]{\cake^\bot}} }$}
\end{prooftree}

\subsection{Servers and sequencing}\label{sec:servers-and-sequencing}
Dual to a pool of $n$ clients in parallel is a server with $n$ actions in sequence. Our interpretation of a server is a process which offers up some number of interdependent interactions of the same type. Examples include the store from our example, which gives out slices of cake and disappointment, online stores in general, and any central server which interacts with some number of client processes.

We introduce two new rules to construct servers. The first rule, $(\give[1]{})$, marks a interaction over some channel as a server interaction. It does this by sending a channel $\tm{y}$ over a \emph{shared} channel $\tm{x}$. The channel $\tm{y}$ is the channel across which the actual interaction will take place. The second rule, $\textsc{Cont}_{?}$, allows us to merge two (possibly interleaved) sequences of server interactions. This allows us to construct a server which has multiple interactions of the same type, across the same shared channel.
\begin{center}
  \ncInfGive1
  \ncInfCont
\end{center}
Using these rules, we can derive the right-hand side of our proof, by marking each of the store's interactions as server interactions, and then contracting them.
\begin{prooftree}
  \AXC{$\seq[{ \store }]{ \Theta, \tmty{z}{\cake}, \tmty{z'}{\cake} }$}
  \SYM{(\give[1]{})}
  \UIC{$\seq[{ \ncSrv{x'}{z'}{\store} }]{
      \Theta, \tmty{z}{\cake}, \tmty{x'}{\give[1]{\cake}} }$}
  \SYM{(\give[1]{})}
  \UIC{$\seq[{ \ncSrv{x}{z}{\ncSrv{x'}{z'}{\store}} }]{
      \Theta, \tmty{x}{\give[1]{\cake}}, \tmty{x'}{\give[1]{\cake}} }$}
  \SYM{\textsc{Cont}_{?}}
  \UIC{$\seq[{ \ncSrv{x}{z}{\ncSrv{x}{z'}{\store}} }]{
      \Theta, \tmty{x}{\give[2]{\cake}} }$}
\end{prooftree}
Thus, we complete the typing derivation of our example.

\begin{definition}[Typing judgements]\label{def:nc-typing-judgement}
  We extend \cref{def:cp-typing-judgement} with the following rules:
  {\normalfont
    \begin{center} \ncInfTake1 \ncInfGive1 \end{center}
    \begin{center} \ncInfPool  \ncInfCont  \end{center}
  }
\end{definition}

\subsection{Running clients and servers}\label{sec:nc-running-clients-and-servers}
Finally, we need to extend the reduction rules to allow for the reduction of client and server processes. The reduction rule we add is a variant of the reduction rule for $\tens$ and $\parr$, $\cpRedBetaTensParr$.
\begin{definition}[Reduction]\label{def:nc-reduction}
  We extend \cref{def:hcp-reduction} with the following reduction:
  \[
    \begin{array}{llll}
      \ncRedBetaStar{}
      & \tm{\piNew{x}{(\piPar{(\piPar{\ncCnt{x}{y}{P}}{\ncSrv{x}{z}{Q}})}{R})}}
      & \Longrightarrow \;
      & \tm{\piNew{x}{(\piPar{\piNew{y}{(\piPar{P}{\cpSub{y}{z}{Q}})}}{R})}}
    \end{array}
  \]
\end{definition}
The difference between $\ncRedBetaStar{}$ and $\cpRedBetaTensParr$ is that the former allows reduction to happen in the presence of an unrelated process $\tm{R}$, which is passed along unchanged. This is necessary, as there may be other clients waiting to interact with the server on the shared channel $\tm{x}$, which cannot be moved out of scope of the name restriction $\piNew{x}{}$. When there is no unrelated process $\tm{R}$, \ie when there is only a single client, we can rewrite by $\hcpEquivMixHalt1$ before and after applying $\ncRedBetaStar{}$.

So where does the non-determinism in \nodcap come from? Let us say we have a term of the following form:
\[
  \tm{
    \cpCut{x}
    {\ncPool{\ncCnt{x}{y_1}{P_1}}{\dots \mid \ncCnt{x}{y_n}{P_n}}}
    {\ncSrv{x}{y_1}{\dots\ncSrv{x}{y_n}{Q}}}
  }
\]
As parallel composition is commutative and associative, we can rewrite this term to pair any client in the pool with the server before applying $\ncRedBetaStar{}$. Thus, like in the \textpi-calculus, the non-determinism is introduced by the structural congruence.

Does this mean that, for an arbitrary client pool $\tm{P}$ in $\tm{\cpCut{x}{P}{\ncSrv{x}{z}{Q}}}$, every client in that pool is competing for the server interaction on $\tm{x}$? Not necessarily, as some portion of the clients can be blocked on an external communication. For instance, in the term below, clients $\tm{\ncCnt{x}{y_{n+1}}{P_{n+1}}} \dots \tm{\ncCnt{x}{y_m}{P_m}}$ are blocked on a communication on the external channel $\tm{a}$:
\[
  \arraycolsep=0pt
  \tm{
  \begin{array}{lrl}
    \nu x.&  ((&\; \ncPool{\ncCnt{x}{y_1}{P_1}}{\dots\mid\ncCnt{x}{y_n}{P_n}}\\
          &\mid&\; \cpWait{a}{\ncPool{\ncCnt{x}{y_{n+1}}{P_{n+1}}}{\dots \mid \ncCnt{x}{y_m}{P_m}}}\;)\\
          &\mid&\; \ncSrv{x}{y_1}{\dots\ncSrv{x}{y_m}{Q}}\;)
  \end{array}}
\]
If we reduce this term, then only the clients $\tm{\ncCnt{x}{y_1}{P_1}} \dots \tm{\ncCnt{x}{y_n}{P_n}}$ will be assigned server interactions, and we end up with the following canonical form:
\[
  \arraycolsep=0pt
  \tm{
  \begin{array}{lrl}
    \nu x.&   (&\; \cpWait{a}{\ncPool{\ncCnt{x}{y_{n+1}}{P_{n+1}}}{\dots\mid\ncCnt{x}{y_m}{P_m}}}\\
          &\mid&\; \ncSrv{x}{y_{n+1}}{\dots\ncSrv{x}{y_m}{Q}}\;)
  \end{array}}
\]
This matches our intuition and the behaviour of the \textpi-calculus.

\paragraph{Alternative syntax.}
If we choose to reuse the terms $\tm{\piSend{x}{y}{P}}$ and $\tm{\piRecv{x}{y}{P}}$ for shared channels, we could replace $\cpRedBetaTensParr$ with $\ncRedBetaStar{}$, using the latter rule for both cases.

\subsection{Metatheory}
\label{sec:nc-metatheory}
\nodcap enjoys subject reduction, termination, and progress.
\begin{lemma}[Preservation for $\equiv$]\label{lem:nc-preservation-equiv}
  If $\tm{P}\equiv\tm{Q}$ and $\seq[P]{\mathcal{G}}$, then $\seq[Q]{\mathcal{G}}$.
\end{lemma} 
\begin{proof}
  By induction on the derivation of $\tm{P}\equiv\tm{Q}$.
\end{proof}
\begin{theorem}[Preservation]\label{thm:nc-preservation}
  If $\seq[P]{\mathcal{G}}$ and $\reducesto{P}{Q}$, then $\seq[Q]{\mathcal{G}}$.
\end{theorem} 
\begin{proof}
  By induction on the derivation of $\reducesto{P}{Q}$.
\end{proof}
\begin{definition}[Actions]
  A process $\tm{P}$ acts on $\tm{x}$ whenever $\tm{x}$ is free in the outermost term constructor of $\tm{P}$, \eg $\tm{\ncSrv{x}{y}{P}}$ acts on $\tm{x}$ but not on $\tm{y}$, and $\tm{\cpLink{x}{y}}$ acts on both $\tm{x}$ and $\tm{y}$. A process $\tm{P}$ is an action if it acts on some channel $\tm{x}$. Two actions are dual when they introduce dual type constructors, \eg $\tm{\piSend{x}{y}{P}}$ is dual to $\tm{\piRecv{x}{z}{Q}}$, but $\tm{\cpLink{x}{y}}$ is not dual to any action.
\end{definition}
\begin{definition}[Canonical forms]\label{def:nc-canonical-forms}
  A process $\tm{P}$ is in canonical form if
  \[
  \tm{P} \equiv \tm{\piNew{x_1}{\dots\piNew{x_n}{(P_1 \mid \dots \mid P_{n+m+1})}}},
  \]
  such that: no process $\tm{P_i}$ is a cut or a mix; no process $\tm{P_i}$ is a link acting on a bound channel $\tm{x_i}$; and no two processes $\tm{P_i}$ and $\tm{P_j}$ are acting on the same bound channel $\tm{x_i}$ with dual actions.
\end{definition}
The new definition of canonical forms is slightly more precise than \cref{def:hcp-canonical-forms}: we added the phrase ``with dual actions''. With the addition of shared channels, it has become possible to have a process which cannot reduce, but in which two processes are waiting to act on the same channel, \eg in $\tm{\ncPool{\ncCnt{x}{y}{\john}}{\ncCnt{x}{y'}{\mary}}}$.
\begin{corollary}
  If a process $\tm{P}$ is in canonical form, then it is blocked on an external communication.
\end{corollary}
\begin{proof}
  We have
  \[
  \tm{P} \equiv \tm{\piNew{x_1}{\dots\piNew{x_n}{(P_1 \ppar \dots \ppar P_{n+m+1})}}},
  \]
  such that no $\tm{P_i}$ is a cut or a link acting on a bound channel, and no two processes $\tm{P_i}$ and $\tm{P_j}$ are acting on the same bound channel with dual actions. The prefix of cuts and mixes introduces $n$ channels. Each application of cut requires an application of mix, so the prefix introduces $n+m+1$ processes. Each application of $\textsc{Cont}_{!}$ requires an application of mix, so there are at most $m$ clients acting on the same bound channel. Therefore, at least \emph{one} of the processes $\tm{P_i}$ must be acting on a free channel, i.e., blocked on an external communication.
\end{proof}
\begin{theorem}[Progress]\label{thm:hcp-progress}
  If $\seq[P]{\Gamma}$, then either $\tm{P}$ is in canonical form, or there exists a process $\tm{Q}$ such that $\tm{P}\Longrightarrow\tm{Q}$.
\end{theorem} 
\begin{proof}
  We consider the maximum prefix of cuts and mixes of $\tm{P}$ such that
  \[
  \tm{P} \equiv \tm{\piNew{x_1}{\dots\piNew{x_n}{(P_1 \ppar \dots \ppar P_{n+m+1})}}},
  \]
  and no $\tm{P_i}$ is a cut. If any process $\tm{P_i}$ is a link, we reduce by $(\cpLink{}{})$. If any two processes $\tm{P_i}$ and $\tm{P_j}$ are acting on the same channel $\tm{x_i}$ with dual actions, we rewrite by $\equiv$ and reduce by the appropriate $\beta$-rule. Otherwise, $\tm{P}$ is in canonical form.
\end{proof}
\begin{theorem}[Termination]\label{thm:hcp-termination}
  If $\seq[P]{\mathcal{G}}$, then there are no infinite $\Longrightarrow$-reduction sequences.
\end{theorem} 
\begin{proof}
  Every reduction reduces a single cut to zero, one or two cuts. However, each of these cuts is smaller, measured in the size of the cut formula. Furthermore, each instance of the structural congruence preserves the size of the cut. Therefore, there cannot be an infinite $\Longrightarrow$-reduction sequence.
\end{proof}

\subsection{\nodcap and non-deterministic local choice}\label{sec:nc-local-choice}
In \cref{sec:local-choice}, we discussed the non-deterministic local choice operator, which is used in several extensions of \piDILL and \cp~\parencite{atkey2016,caires2014,caires2017}. This operator is admissible in \nodcap. We can derive the non-deterministic choice \tm{P+Q} by constructing the following term:
\[%
  \arraycolsep=0pt
  \tm{
  \begin{array}{lrlrl}
    \nu x.&((  & \; \ncCnt{x}{y}{\cpInl{y}{\cpHalt{y}}} \\
          &\mid& \; \ncCnt{x}{z}{\cpInr{z}{\cpHalt{z}}} \; )\\
          &\mid& \; \ncSrv{x}{y}{\ncSrv{x}{z}{}}\text{case}\;y\\
          &    & \quad
                 \begin{array}{rl}
                   \{ & \texttt{inl}: \; \cpCut{w}{\cpCase{z}{\cpWait{z}{\cpHalt{w}}}{
                           \cpWait{z}{\cpHalt{w}}}}{\cpWait{w}{P}}
                   \\
                    ; & \texttt{inr}: \; \cpCut{w}{\cpCase{z}{\cpWait{z}{\cpHalt{w}}}{
                           \cpWait{z}{\cpHalt{w}}}}{\cpWait{w}{Q}} \; \})
                 \end{array}
  \end{array}
  }
\]
This term is a cut between two processes.
\begin{itemize}
\item
  On the left-hand side, we have a pool of two processes, \tm{\ncCnt{x}{y}{\cpInl{y}{\cpHalt{y}}}} and \tm{\ncCnt{x}{z}{\cpInr{z}{\cpHalt{z}}}}. Each makes a choice: the first sends \tm{\text{inl}}, and the second sends \tm{\text{inr}}. 
\item
  On the right-hand side, we have a server with both \tm{P} and \tm{Q}. This server has two channels on which a choice is offered, \tm{y} and \tm{z}. The choice on \tm{y} selects between \tm{P} and \tm{Q}. The choice on \tm{z} does not affect the outcome of the process at all. Instead, it is discarded.
\end{itemize}
When these clients and the server are put together, the choices offered by the server will be non-deterministically lined up with the clients which make choices, and either \tm{P} or \tm{Q} will run.

While there is a certain amount of overhead involved in this encoding, it scales linearly in terms of the number of processes. The reverse---encoding the non-determinism present in \nodcap using non-deterministic local choice---scales exponentially, see, \eg the examples in \cref{sec:local-choice}.


\section{Cuts with leftovers}
So far, our account of a non-determinism in client/server interactions only allows for interactions between equal numbers of clients and servers. A natural question is whether or not we can deal with the scenario in which there are more client than server interactions or vice versa, \ie whether or not the following rule, and its dual with leftovers of type $\ty{\give[m]{A^\bot}}$, are derivable:
\begin{prooftree}
  \AXC{$\seq[{ P }]{ \Gamma, \tmty{x}{\take[n+m]{A}} }$}
  \AXC{$\seq[{ Q }]{ \Delta, \tmty{x}{\give[n]{A^\bot}} }$}
  \BIC{$\seq[{ \cpCut{x}{P}{Q} }]{ \Gamma, \Delta, \tmty{x}{\take[m]{A}} }$}
\end{prooftree}
As it turns out these rules are easily derivable using a link. For instance, we can derive the rule for the case in which there are more clients than servers as follows:
\begin{prooftree}
  \AXC{$\seq[{ P }]{ \Gamma, \tmty{x}{\take[n+m]{A}} }$}
  \AXC{$\seq[{ Q }]{ \Delta, \tmty{x}{\give[n]{A^\bot}} }$}
  \AXC{$\seq[{ \cpLink{x}{w} }]{
      \tmty{x'}{\give[m]{A^{\bot}}}, \tmty{w}{\take[m]{A}} }$}
  \NOM{H-Mix}
  \BIC{$\seq[{ (\piPar{Q}{\cpLink{x}{w}}) }]{
      \Delta, \tmty{x}{\give[n]{A^\bot}} \hsep
      \tmty{x'}{\give[m]{A^{\bot}}}, \tmty{w}{\take[m]{A}} }$}
  \SYM{\textsc{Cont}_{!}}
  \UIC{$\seq[{ {(\piPar{Q}{\cpLink{x}{w}})} }]{
      \Delta, \tmty{x}{\give[n+m]{A^\bot}}, \tmty{w}{\take[m]{A}} }$}
  \NOM{H-Mix}
  \BIC{$\seq[{ (\piPar{P}{Q}) }]{
      \Gamma, \tmty{x}{\take[n+m]{A}} \hsep
      \Delta, \tmty{x}{\give[n+m]{A^\bot}}, \tmty{w}{\take[m]{A}} }$}
  \NOM{Cut}
  \UIC{$\seq[{ \piNew{x}{(\piPar{P}{Q})} }]{
      \Gamma, \Delta, \tmty{w}{\take[m]{A}} }$}
\end{prooftree}



\section{Discussion and Future Work}\label{sec:discussion}
We have presented \nodcap, an extension of \hcp which permits non-deterministic communication without losing the strong connection to logic.
We have given proofs for preservation, progress, and termination for the term reduction system of \nodcap.
We have shown that we can define non-deterministic local choice in \nodcap.

\subsection{Recursion, variable resources, and exponentials}
Our formalism so far has only captured servers that provide for a fixed number of clients.  More realistically, we would want to define servers that provide for arbitrary numbers of clients.  This poses two problems: how would we define arbitrarily-interacting stateful processes, and how would we extend the typing discipline of \nodcap to account for them without losing its static guarantees.

One approach to defining server processes would be to combine \nodcap with structural recursion and corecursion, following the $\mu\text{CP}$ extension of~\textcite{lindley2016}.  Their approach can express processes which produce streams of \ty{A} channels. Such a process would expose a channel with the co-recursive type \ty{\nu X. A \parr (1 \plus X)}.  Given such a process, it is possible to produce a channel of type \ty{A \parr A \parr \cdots \parr A} for any number of \ty{A}s, allowing us to satisfy the type \ty{\give[n]{A}} for an arbitrary $n$.

We would also need to extend the typing discipline to capture arbitrary use of shared channels.  One approach would be to introduce resource variables and quantification.  Following this approach, in addition to having types \ty{\give[n] A} and \ty{\take[n] A} for concrete $n$, we would also have types \ty{\give[x] A} and \ty{\take[x] A} for resource variables $x$.  These variables would be introduced by quantifiers \ty{\forall x A} and \ty{\exists x A}. Defining terms corresponding to \ty{\forall x A}, and its relationship with structured recursion, presents an interesting area of further work.

Our account of \hcp did not include the exponentials \ty{\give A} and \ty{\take A}. The type \ty{\take A} denotes arbitrarily many independent instances of \ty{A}, while the type \ty{\give A} denotes a concrete (if unspecified) number of potentially-dependent instances of \ty{A}.  Existing interpretations of linear logic as session types have taken \ty{\take A} to denote \ty{A}-servers, while \ty{\give A} denotes \ty{A}-clients.  However, the analogy is imperfect: while we expect servers to provide arbitrarily many instances of their behaviour, we also expect those instances to be interdependent.

With quantification over resource variables, we can give precise accounts of both \cp's exponentials and idealised servers and clients. \cp exponentials could be embedded into this framework using the definitions $\ty{\take{A}} ::= \ty{\forall{n}\take[n]{A}}$ and $\ty{\give{A}} ::= \ty{\exists{n}{\give[n]{A}}}$. We would also have types that precisely matched our intuitions for server and client behavior: an \ty{A} server is of type \ty{\forall{n}{\give[n] A}}, as it serves an unbounded number of requests with the requests being interdependent, while a collection of \ty{A} clients is of type \ty{\exists{n}{\take[n] A}}, as we have a specific number of clients with each client being independent.

\clearpage
\printbibliography

\end{document}
%%% Local Variables:
%%% TeX-master: "main"
%%% End:
