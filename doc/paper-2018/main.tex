\documentclass[UKenglish]{llncs}
\usepackage{makeidx}
\input{preamble}
\input{preamble-emoji}
\input{preamble-typing}
\usepackage{thm-restate}
\usepackage[title]{appendix}
\pagestyle{plain}
\addbibresource{main.bib}
\arraycolsep=1ex
\mainmatter % start of the contributions
\title{Races in Classical Linear Logic}
\titlerunning{Races in Classical Linear Logic} 
\author{Wen Kokke \and J.\ Garrett Morris \and Philip Wadler}
\tocauthor{Wen Kokke, J.\ Garrett Morris, and Philip Wadler}
\institute{University of Edinburgh, Edinburgh, UK,\\
\email{wen.kokke@ed.ac.uk}}
\begin{document}

\maketitle % typeset the title of the contribution

\begin{abstract}
  Process calculi based in logic, such as \piDILL and CP, provide a foundation
  for deadlock-free concurrent programming, but exclude non-determinism and
  races.
  We introduce \nodcap, which extends CP with a novel account of
  non-determinism.
  Our approach draws on bounded linear logic to provide a strongly-typed
  account of standard process calculus expressions of non-determinism.
  We show that our extension is expressive enough to capture many uses of
  non-determinism in untyped calculi, such as non-deterministic choice, while
  preserving CP's meta-theoretic properties, including deadlock freedom.  
\end{abstract}

%% Introduction
\section{Introduction}\label{sec:introduction}

Consider the following scenario:
\begin{quote}
  John and Mary are working from home one morning when they each get a craving
  for a slice of cake. Being denizens of the web, they quickly find the nearest
  store which does home deliveries.
  Unfortunately for them, they both order their cake at the \emph{same} store,
  which has only one slice left. After that, all it can deliver is
  disappointment.
\end{quote}
This is an example of a \emph{race condition}. We can model this scenario in the
\textpi-calculus, where \john, \mary and \store are processes modelling John,
Mary and the store, and \sliceofcake and \nope are channels giving access to a
slice of cake and disappointment, respectively.
This process has two possible outcomes: either John gets the cake, and Mary gets
disappointment, or vice versa. 
\[
  \begin{array}{c}
    \tm{(\piPar{%
    \piSend{x}{\sliceofcake}{\piSend{x}{\nope}{\store}}
    }{%
    \piPar{\piRecv{x}{y}{\john}}{\piRecv{x}{z}{\mary}}
    })}
    \\[1ex]
    \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
    \\[1ex]
    \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\john}}{%
    \piSub{\nope}{z}{\mary}}})}
    \quad
    \text{or}
    \quad
    \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\john}}{%
    \piSub{\sliceofcake}{z}{\mary}}})}
  \end{array}
\]
While John or Mary may not like all of the outcomes, it is the store which is
responsible for implementing the online delivery service, and the store is happy
with either outcome. Thus, the above is an interaction we would like to be able to
model.

Now consider another scenario, which takes place \emph{after} John has already
bought the cake:
\begin{quote}
  Mary is \emph{really} disappointed when she finds out the cake has sold out.
  John, always looking to make some money, offers to sell the slice to her for a
  profit. Mary agrees to engage in a little bit of back-alley cake resale, but
  sadly there is no trust between the two.
  John demands payment first.
  Mary would rather get her slice of cake before she gives John the money.
\end{quote}
This is an example of a \emph{deadlock}. We can also model this scenario in the
\textpi-calculus, where \bill\ is a channel giving access to some adequate
amount of money. 
\[
  \begin{array}{c}
    \tm{(\piPar{%
    \piRecv{x}{z}{\piSend{y}{\sliceofcake}{\john}}
    }{%
    \piRecv{y}{w}{\piSend{x}{\bill}{\mary}}
    })}
    \quad
    \centernot\Longrightarrow^{\star}
  \end{array}  
\]
The above process does not reduce. As both John and Mary would prefer the
exchange to be made, this interaction is desired by \emph{neither}. Thus, the
above is an interaction we would \emph{somehow} like to exclude.

Session types~\parencite{honda1993} statically guarantee that concurrent
programs, such as those above, respect communication protocols.
Session-typed calculi with logical foundations, such as
\piDILL~\parencite{caires2010} and CP~\parencite{wadler2012}, obtain deadlock freedom as a
result of a close correspondence with logic.
These systems, however, also rule out non-determinism and race conditions. In
this paper, we demonstrate that logic-inspired type systems need not rule out
races.

We present \nodcap (nodcap), an extension of CP with a novel account of
non-determinism and races.
Inspired by bounded linear logic~\parencite{girard1992}, we introduce a form of
shared channels in which the type of a shared channel tracks how many times it
is reused.
As in the untyped $\pi$-calculus, sharing introduces the potential for
non-determinism.
We show that our approach is sufficient to capture practical examples of races,
such as an online store, as well as other formal characterizations of
non-determinism, such as non-deterministic choice.  However, \nodcap does not
lose the meta-theoretical benefits of CP: we show that it enjoys termination and
deadlock-freedom.

This paper proceeds as follows.
In \cref{sec:local-choice}, we discuss recent approaches to non-determinism in
logic-inspired session-typed process calculi.
In \cref{sec:cp-revisited}, we introduce a variant of \cp and prove progress and
preservation.
In \cref{sec:cpnd}, we introduce \nodcap.
Finally, in \cref{sec:discussion}, we conclude with a discussion of the work
done in this paper and potential avenues for future work.

\section{Non-determinism, logic, and session types}
\label{sec:local-choice}
Recent work extended \piDILL and \cp with operators for non-deterministic
behaviour~\parencite{atkey2016,caires2014,caires2017}.
These extensions all implement an operator known as non-deterministic local
choice. (This operator is written as \tm{P+Q}, but should not be confused with
input-guarded choice from the \textpi-calculus~\parencite{milner1992b}.)
Non-deterministic local choice can be summarised by the following typing and
reduction rules:
\begin{center}
  \begin{prooftree*}
    \AXC{$\seq[{ P }]{ \Gamma }$}
    \AXC{$\seq[{ Q }]{ \Gamma }$}
    \BIC{$\seq[{ P + Q }]{ \Gamma }$}
  \end{prooftree*}
  \hspace*{2cm}
  \(
  \begin{array}{c}
    \reducesto{P + Q}{P}\\
    \reducesto{P + Q}{Q}
  \end{array}
  \)
\end{center}
Local choice introduces non-determinism explicitly, by listing all possible
choices. This is unlike the \textpi-calculus, where non-determinism arises due
to multiple processes communicating on shared channels. We can easily implement
local choice in the \textpi-calculus, using a nullary communication:
\[
  \begin{array}{c}
    \tm{( \piPar{\piPar{\piSend{x}{}{\piHalt}}{\piRecv{x}{}{P}}}{\piRecv{x}{}{Q}} )}
    \\[1ex]
    \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
    \\[1ex]
    \tm{( \piPar{P}{\piRecv{x}{}{Q}} )}
    \quad
    \text{or}
    \quad
    \tm{( \piPar{\piRecv{x}{}{P}}{Q} )}
  \end{array}
\]
In this implementation, the process \tm{\piSend{x}{}{0}} will ``unlock'' either
\tm{P} or \tm{Q}, leaving the other process deadlocked. Or we could use
input-guarded choice:
\[
  \tm{( \piPar{\piSend{x}{}{\piHalt}}{( \piRecv{x}{}{P} + \piRecv{x}{}{Q} )} )}
\]
However, there are many non-deterministic processes in the \textpi-calculus
that are awkward to encode using non-deterministic local choice.
Let us recall our example:
\[
  \begin{array}{c}
    \tm{(\piPar{%
    \piSend{x}{\sliceofcake}{\piSend{x}{\nope}{\store}}
    }{%
    \piPar{\piRecv{x}{y}{\john}}{\piRecv{x}{z}{\mary}}
    })}
    \\[1ex]
    \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
    \\[1ex]
    \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\john}}{
    \piSub{\nope}{z}{\mary}}})}
    \quad
    \text{or}
    \quad
    \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\john}}{\piSub{
    \sliceofcake}{z}{\mary}}})}
  \end{array}
\]
This non-deterministic interaction involves communication. If we wanted to write
down a process which exhibited the same behaviour using non-deterministic local
choice, we would have to write the following process:
\[
  \begin{array}{c}
    \tm{
    (\piPar{%
    \piSend{x}{\sliceofcake}{\piSend{y}{\nope}{\store}}
    }{%
    \piPar{\piRecv{x}{z}{\john}}{\piRecv{y}{w}{\mary}}
    })
    +
    (\piPar{%
    \piSend{y}{\sliceofcake}{\piSend{x}{\nope}{\store}}
    }{%
    \piPar{\piRecv{x}{z}{\john}}{\piRecv{y}{w}{\mary}}
    })
    }
    \\[1ex]
    \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
    \\[1ex]
    \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\john}}{\piSub{\nope}{z}{\mary}}})}
    \quad
    \text{or}
    \quad
    \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\john}}{\piSub{\sliceofcake}{z}{\mary}}})}
  \end{array}
\]
In essence, instead of modelling a non-deterministic interaction, we are
enumerating the resulting deterministic interactions.
This means non-deterministic local choice cannot model non-determinism in the
way the \textpi-calculus does.
%
Enumerating all possible outcomes becomes worse the more processes are involved
in an interaction. Imagine a scenario the following scenario:
\begin{quote}
  Three customers, Alice, John and Mary, have a craving for cake. Should cake be
  sold out, however, well... a doughnut will do. They prepare to order their
  goods via an online store. Unfortunately, they all decide to use the
  same \emph{shockingly} under-stocked store, which has only one slice of cake,
  and a single doughnut. After that, all it can deliver is disappointment.
\end{quote}
We can model this scenario in the \textpi-calculus, where \alice, \john,
\mary, and \store are four processes modelling Alice, John, Mary and the store,
and \sliceofcake, \doughnut, and \nope are three channels giving access to a
slice of cake, a so-so doughnut, and disappointment, respectively.
\begin{center}
  \makebox[\textwidth][c]{\ensuremath{
      \begin{array}{c}
        \tm{(\piPar{%
        \piSend{x}{\sliceofcake}{\piSend{x}{\doughnut}{\piSend{x}{\nope}{\store}}}
        }{%
        \piPar{\piRecv{x}{y}{\alice}}{\piPar{\piRecv{x}{z}{\john}}{\piRecv{x}{w}{\mary}}
        })}}
        \\[1ex]
        \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
        \\[1ex]
        \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\alice}}{\piPar{\piSub{\doughnut}{z}{\john}}{\piSub{\nope}{w}{\mary}}}})}
        \;
        \text{or}
        \;
        \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\alice}}{\piPar{\piSub{\nope}{z}{\john}}{\piSub{\doughnut}{w}{\mary}}}})}
        \\[1ex]
        \tm{(\piPar{\store}{\piPar{\piSub{\doughnut}{y}{\alice}}{\piPar{\piSub{\nope}{z}{\john}}{\piSub{\sliceofcake}{w}{\mary}}}})}
        \;
        \text{or}
        \;
        \tm{(\piPar{\store}{\piPar{\piSub{\doughnut}{y}{\alice}}{\piPar{\piSub{\sliceofcake}{z}{\john}}{\piSub{\nope}{w}{\mary}}}})}
        \\[1ex]
        \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\alice}}{\piPar{\piSub{\sliceofcake}{z}{\john}}{\piSub{\doughnut}{w}{\mary}}}})}
        \;
        \text{or}
        \;
        \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\alice}}{\piPar{\piSub{\doughnut}{z}{\john}}{\piSub{\sliceofcake}{w}{\mary}}}})}
        \\[1ex]
      \end{array}
    }}
\end{center}
With the addition of one process, modelling Alice, we have increased the number
of possible outcomes enormously! In general, the number of outcomes for these
types of scenarios is $n!$, where $n$ is the number of processes. This means
that if we wish to translate any non-deterministic process to one using
non-deterministic local choice, we can expect a factorial growth in the size of
the term.

\section{Classical Processes Revisited}\label{sec:cp-revisited}

In this section, we introduce a reformulation of \cp.
To keep the discussion simple, we will only discuss the subset which corresponds
to multiplicative-additive linear logic~\cite[MALL]{girard1987} or rudimentary
linear logic~\cite[RLL]{girard1992}.
We foresee no problems in extending the proofs from \cref{sec:cpnd} to
cover the remaining features of \cp, polymophism and the exponentials $\ty{!A}$
and $\ty{?A}$. 

We deviate from the original presentation of \cp~\parencite{wadler2012} in two ways:
we include the commutativity of links in our structural congruence, as done by
\textcite{paykin2016}; and, inspired by \textcite{lindley2015semantics}, we
exclude the commutative conversions from our reduction system which leads to a 
different notion of canonical form and a reduction strategy closer to that of
the \textpi-calculus.

The term language for \cp is a variant of the
\textpi-calculus~\parencite{milner1992b}.
\begin{definition}[Terms]\label{def:cp-terms}
  \[\!
    \begin{aligned}
      \tm{P}, \tm{Q}, \tm{R}
           :=& \; \tm{\cpLink{x}{y}}       &&\text{link}
      \\ \mid& \; \tm{\cpCut{x}{P}{Q}}     &&\text{parallel composition, or ``cut''}
      \\ \mid& \; \tm{\cpSend{x}{y}{P}{Q}} &&\text{``output''}
      \\ \mid& \; \tm{\cpRecv{x}{y}{P}}    &&\text{``input''}
      \\ \mid& \; \tm{\cpHalt{x}}          &&\text{halt}
      \\ \mid& \; \tm{\cpWait{x}{P}}       &&\text{wait}
      \\ \mid& \; \tm{\cpInl{x}{P}}        &&\text{select left choice}
      \\ \mid& \; \tm{\cpInr{x}{P}}        &&\text{select right choice}
      \\ \mid& \; \tm{\cpCase{x}{P}{Q}}    &&\text{offer binary choice}
      \\ \mid& \; \tm{\cpAbsurd{x}}        &&\text{offer nullary choice}
    \end{aligned}
  \]  
  \qed
\end{definition}
The variables \tm{x}, \tm{y}, \tm{z} and \tm{w} range over channel names.
The construct \tm{\cpLink{x}{y}} links two
channels~\parencite{sangiorgi1996,boreale1998}, forwarding messages received on
\tm{x} to \tm{y} and vice versa.
The construct \tm{\cpCut{x}{P}{Q}} creates a new channel \tm{x}, and composes
two processes, \tm{P} and \tm{Q}, which communicate on \tm{x}, in parallel.
Therefore, in \tm{\cpCut{x}{P}{Q}} the name \tm{x} is bound in both \tm{P} and
\tm{Q}.
In \tm{\cpRecv{x}{y}{P}} and \tm{\cpSend{x}{y}{P}{Q}}, round brackets denote
input, square brackets denote output. 
We use bound output~\parencite{sangiorgi1996}, meaning that both input and output
bind a new name. 
In \tm{\cpRecv{x}{y}{P}} the new name \tm{y} is bound in \tm{P}.
In \tm{\cpSend{x}{y}{P}{Q}}, the new name \tm{y} is bound in \tm{P}, while
\tm{x} occurs in \tm{Q}.

Terms in \cp are identified up to structural congruence, which states that
parallel compositions \tm{\cpCut{x}{P}{Q}} are associative and commutative.
\begin{definition}[Structural congruence]\label{def:cp-equiv}
  We define the structural congruence $\equiv$ as a reflexive, transitive
  congruence over terms which satisfies the following additional axioms:
  \[
    \begin{array}{llll}
      \cpEquivLinkComm
      & \tm{\cpLink{x}{y}}
      & \equiv \;
      & \tm{\cpLink{y}{x}}
      \\
      \cpEquivCutComm
      & \tm{\cpCut{x}{P}{Q}}
      & \equiv \;
      & \tm{\cpCut{x}{Q}{P}}
      \\
      \cpEquivCutAss1
      & \tm{\cpCut{x}{P}{\cpCut{y}{Q}{R}}}
      & \equiv \;
      & \tm{\cpCut{y}{\cpCut{x}{P}{Q}}{R}}
        \quad \text{if} \; \notFreeIn{x}{R} \; \text{and} \; \notFreeIn{y}{P}
    \end{array}
  \]
  \qed
\end{definition}
We do not add an axiom for \cpEquivCutAss2, as it follows from
\cref{def:cp-equiv}.
Throughout this paper, we will leave uses of the transitivity and
congruence rules implicit.
Structural congruence is a symmetric relation.
%
Channels in \cp are typed using a session type system which corresponds to RLL.
\begin{definition}[Types]\label{def:cp-types}
  \[\!
    \begin{aligned}
      \ty{A}, \ty{B}, \ty{C}
           :=& \; \ty{A \tens B} &&\text{pair of independent channels}
      \\ \mid& \; \ty{A \parr B} &&\text{pair of interdependent channels}
      \\ \mid& \; \ty{\one}      &&\text{unit for} \; {\tens}
      \\ \mid& \; \ty{\bot}      &&\text{unit for} \; {\parr}
      \\ \mid& \; \ty{A \plus B} &&\text{internal choice}
      \\ \mid& \; \ty{A \with B} &&\text{external choice}
      \\ \mid& \; \ty{\nil}      &&\text{unit for} \; {\plus}
      \\ \mid& \; \ty{\top}      &&\text{unit for} \; {\with}
    \end{aligned}
  \]  
  \qed
\end{definition}
Duality plays a crucial role in both linear logic and session types.
In \cp, the two endpoints of a channel are assigned dual types.
This ensures that, for instance, whenever a process \emph{sends} across a
channel, the process on the other end of that channel is waiting to
\emph{receive}.
Each type \ty{A} has a dual, written \ty{A^\bot}.
Duality (\ty{\cdot^\bot}) is an involutive function on types.
\begin{definition}[Duality]\label{def:cp-negation}
  \[\!
    \begin{array}{lclclcl}
              \ty{(A \tens B)^\bot} &=& \ty{A^\bot \parr B^\bot}
      &\quad& \ty{\one^\bot}        &=& \ty{\bot}
      \\      \ty{(A \parr B)^\bot} &=& \ty{A^\bot \tens B^\bot}
      &\quad& \ty{\bot^\bot}        &=& \ty{\one}
      \\      \ty{(A \plus B)^\bot} &=& \ty{A^\bot \with B^\bot}
      &\quad& \ty{\nil^\bot}        &=& \ty{\top}
      \\      \ty{(A \with B)^\bot} &=& \ty{A^\bot \plus B^\bot}
      &\quad& \ty{\top^\bot}        &=& \ty{\nil}
    \end{array}
  \]
  \qed
\end{definition}
Environments associate channels with types.
\begin{definition}[Environments]\label{def:cp-environments}
  \[
    \ty{\Gamma}, \ty{\Delta}, \ty{\Theta}
    ::= \tmty{x_1}{A_1}\dots\tmty{x_n}{A_n}
  \] 
  Names in environments must be unique, and environments \ty{\Gamma} and
  \ty{\Delta} can only be combined ($\ty{\Gamma}, \ty{\Delta}$) if
  $\text{fv}(\ty{\Gamma}) \cap \text{fv}(\ty{\Delta}) = \varnothing$. 
  \qed
\end{definition}
Typing judgements associate processes with collections of typed channels.
\begin{definition}[Typing judgements]\label{def:cp-typing-judgement}
  A typing judgement $\seq[{ P }]{\tmty{x_1}{A_1}\dots\tmty{x_n}{A_n}}$ denotes
  that the process \tm{P} communicates along channels $\tm{x_1}\dots\tm{x_n}$
  following protocols $\ty{A_1}\dots\ty{A_n}$.
  Typing judgements can be constructed using the following rules:
  {\normalfont
    \begin{center} \cpInfAx    \cpInfCut   \end{center}
    \begin{center} \cpInfTens  \cpInfParr  \end{center}
    \begin{center} \cpInfOne   \cpInfBot   \end{center}
    \begin{center} \cpInfPlus1 \cpInfPlus2 \end{center}
    \begin{center} \cpInfWith              \end{center}
    \begin{center} \cpInfNil   \cpInfTop   \end{center}
  }
  \qed
\end{definition}
Reductions relate processes with their reduced forms.
They are defined as follows:
\begin{definition}[Term reduction]\label{def:cp-term-reduction}
  A reduction $\reducesto{P}{P'}$ denotes that the process \tm{P} can reduce to
  the process \tm{P'} in a single step. Reductions can only be constructed using
  the following rules:
  \[
    \begin{array}{llll}
      \cpRedAxCut1
      & \tm{\cpCut{x}{\cpLink{w}{x}}{P}}
      & \Longrightarrow \;
      & \tm{\cpSub{w}{x}{P}} 
      \\
      \cpRedBetaTensParr
      & \tm{\cpCut{x}{\cpSend{x}{y}{P}{Q}}{\cpRecv{x}{z}{R}}}
      & \Longrightarrow \;
      & \tm{\cpCut{y}{P}{\cpCut{x}{Q}{\cpSub{y}{z}{R}}}}
      \\
      \cpRedBetaOneBot
      & \tm{\cpCut{x}{\cpHalt{x}}{\cpWait{x}{P}}}
      & \Longrightarrow \;
      & \tm{P}
      \\
      \cpRedBetaPlusWith1
      & \tm{\cpCut{x}{\cpInl{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow \;
      & \tm{\cpCut{x}{P}{Q}}
      \\
      \cpRedBetaPlusWith2
      & \tm{\cpCut{x}{\cpInr{x}{P}}{\cpCase{x}{Q}{R}}}
      & \Longrightarrow \;
      & \tm{\cpCut{x}{P}{R}}
    \end{array}
  \]
  \begin{prooftree}
    \AXC{\reducesto{P}{P^\prime}}
    \SYM{\cpRedGammaCut}
    \UIC{\reducesto{\cpCut{x}{P}{Q}}{\cpCut{x}{P^\prime}{Q}}}
  \end{prooftree}
  \begin{prooftree}
    \AXC{$\tm{P}\equiv\tm{Q}$}
    \AXC{\reducesto{Q}{Q^\prime}}
    \AXC{$\tm{Q^\prime}\equiv\tm{P^\prime}$}
    \SYM{\cpRedGammaEquiv}
    \TIC{\reducesto{P}{P^\prime}}
  \end{prooftree}
  %
  The relation $\Longrightarrow^\star$ is the reflexive, transitive closure of
  $\Longrightarrow$.
  \qed
\end{definition}
We will discuss the interpretations of each connective, together with their
typing and reduction rules, in \cref{sec:cp-multiplicatives,sec:cp-additives,sec:cp-duality}.

\subsection{Multiplicatives and in- and interdependence}
\label{sec:cp-multiplicatives}
The multiplicatives ($\ty{\tens}, \ty{\parr}$) express independence and
interdependence:
\begin{itemize}
\item
  A channel of type \ty{A \tens B} represents a pair of channels which
  communicate with two independent processes---that is to say, two
  processes who share no channels.
  A process acting on a channel of type \ty{A \tens B} will send one endpoint of
  a fresh channel, and then split into a pair of independent processes.
  One of these processes will be responsible for an interaction of type \ty{A}
  over the fresh channel, while the other process continues to interact as
  \ty{B}.
\item
  A channel of type \ty{A \parr B} represents a pair of interdependent channels,
  which are used within a single process.
  A process acting on a channel of type \ty{A \parr B} will receive a channel to
  act on, and communicate on its channels in whatever order it pleases.
  This means that the usage of one channel can depend on that of
  another---e.g.\ the interaction of type \ty{B} could depend on the result of
  the interaction of type \ty{A}, or vise versa, and if \ty{A} and \ty{B} are
  complex types, their interactions could likewise interweave in complex ways.
\end{itemize}
While the rules for \ty{\tens} and \ty{\parr} introduce input and output
operations, these are inessential---the essential distinction lies two in the
fact that (\tens) composes two independent processes, and therefore \emph{must}
split the environment between them, whereas (\parr) uses a single process, which
then can---and must---use all the channels in the environment.
\begin{center}
  \cpInfTens
  \cpInfParr
\end{center}
The \textbeta-reduction rule for terms introduced by $(\tens)$ and $(\parr)$
implements the behaviour outlined above:
\[
  \tm{\cpCut{x}{\cpSend{x}{y}{P}{Q}}{\cpRecv{x}{z}{R}}}
  \Longrightarrow
  \tm{\cpCut{y}{P}{\cpCut{x}{Q}{\cpSub{y}{z}{R}}}}
\]
The function \tm{\cpSub{x}{y}{P}} denotes the substitution of the name \tm{x}
for the name \tm{y} in the term \tm{P}.
%
The rules for the multiplicative units ($\ty{\one}, \ty{\bot}$) follow the same
pattern, except for the nullary instead of the binary case:
\begin{itemize}
\item
  A term constructed by $(\one)$ must compose \emph{zero} independent
  processes, and thus must halt. Furthermore, it must be able to split its
  environment between zero processes, and thus its environment must be empty.
\item
  A term constructed by $(\bot)$, on the other hand, consists of a single
  process, which is not further restricted.
\end{itemize}
The rules for $\ty{\one}$ and $\ty{\bot}$ introduce a nullary send and receive
operation, such as those found in the polyadic \textpi-calculus~\parencite{milner1993}. 
\begin{center}
  \cpInfOne
  \cpInfBot
\end{center}
The \textbeta-reduction rule for terms introduced by $(\one)$ and $(\bot)$
implements the behaviour outlined above:
\[
  \tm{\cpCut{x}{\cpHalt{x}}{\cpWait{x}{P}}}
  \Longrightarrow
  \tm{P}
\]

\subsection{Additives and choice}
\label{sec:cp-additives}
The additives ($\ty{\plus}, \ty{\with}$) express choice:
\begin{itemize}
\item
  A process acting on a channel of type \ty{A \plus B} either sends the value
  \tm{\text{inl}} to select an interaction of type \ty{A} or the value
  \tm{\text{inr}} to select one of type \ty{B}. 
\item
  A process acting on a channel of type \ty{A \with B} receives such a value,
  and then offers an interaction of either type \ty{A} or \ty{B},
  correspondingly.
\end{itemize}
In essence, the additive operations implement sending and receiving of a single
bit of information (\tm{\text{inl}} or \tm{\text{inr}}) and branching based on
the value of that bit. 
\begin{center}
  \cpInfPlus1
  \cpInfWith
\end{center}
The rule for constructing a process which sends \tm{\text{inr}}, $(\plus_2)$,
has been omitted, but can be found in~\cref{def:cp-typing-judgement}.
The \textbeta-reduction rules for terms introduced by $(\plus_1)$, $(\plus_2)$
and $(\with)$ implement the behaviour outlined above.
\[
  \begin{array}{c}
    \tm{\cpCut{x}{\cpInl{x}{P}}{\cpCase{x}{Q}{R}}} \Longrightarrow \tm{\cpCut{x}{P}{Q}}
    \\
    \tm{\cpCut{x}{\cpInr{x}{P}}{\cpCase{x}{Q}{R}}} \Longrightarrow \tm{\cpCut{x}{P}{R}}
  \end{array}
\]
%
The rules for the additive units ($\ty{\nil}, \ty{\top}$) follow the same
pattern, except for a nullary choice:
\begin{itemize}
\item
  There is \emph{no} rule for \ty{\nil}, as a process acting on a channel of
  that type would have to select one of \emph{zero} options, which is impossible.
\item
  A process acting on a channel of type \ty{\top} will wait to receive a choice
  of \emph{zero} options. Since this will clearly never happen, we have two
  options: either we wait forever, or we crash.
\end{itemize}
It may seem odd at first to include a type for the process which cannot possibly
exist, and for the process which waits forever, but these make sensible units
for choice.
When offered a choice of type \ty{A \plus \nil}, one can either choose to
interact as \ty{A}, or choose to commit to doing the impossible.
Similarly, when offering a choice of type \ty{A \with \top}, one can safely
implement the right branch with a process which waits forever, as no sound
process will ever be able to select that branch anyway.
\begin{center}
  \cpInfNil
  \cpInfTop
\end{center}
As there is no way to construct a process of type \ty{\nil}, there is no
reduction rule for the additive units.


\subsection{Structural rules and duality}
\label{sec:cp-duality}
Duality plays a crucial role in session type systems.
In~\cref{sec:cp-additives}, we saw that duality ensures a process offering a choice
is always matched with a process making a choice.
In~\cref{sec:cp-multiplicatives}, we saw that it also ensures that, for instance
a process which uses communication on \tm{x} to decide what to send on \tm{y} is
matched with a pair of independent processes on \tm{x} and \tm{y}, which is
crucial to deadlock freedom as it prevents circular dependencies.  

Duality appears in the typing rules for two \cp term constructs.
Forwarding, \tm{\cpLink{x}{y}}, connects two dual channels with dual endpoints,
while composition, \tm{\cpCut{x}{P}{Q}}, composes two processes \tm{P} and
\tm{Q} with a shared channel \tm{x}, requiring that they follow dual protocols
on \tm{x}.
\begin{center}
  \cpInfAx
  \cpInfCut
\end{center}
There are two reduction rules which deal with the interactions between
forwarding and compositions. These implement the intuition that if a process is
meant to communicate on \tm{x}, \tm{x} is forwarding to \tm{y}, and nobody else
is listening on \tm{x}, then the process might as well start communicating on
\tm{y}.
\[
  \tm{\cpCut{x}{\cpLink{w}{x}}{P}} \Longrightarrow \tm{\cpSub{w}{x}{P}} 
\]
We can do this because \cp implements a \emph{binary} session type system,
meaning that each communication has only two participants, and therefore we know
that no other process is communicating on \tm{x}.

\subsection{Example}
\label{sec:cp-example}
The multiplicatives are responsible for structuring communication, and
it is this structure which rules out deadlocked interactions.
Let us go back to our example of a deadlocked interaction from
\cref{sec:introduction}:
\[
  \tm{(\piPar{%
      \piRecv{x}{z}{\piSend{y}{\sliceofcake}{\john}}
    }{%
      \piRecv{y}{w}{\piSend{x}{\bill}{\mary}}
    })}
\]
If we want to translate this interaction to \cp, we run into a problem: there is
no \emph{plain} sending construct in \cp---we only have \tm{\cpSend{x}{y}{P}{Q}},
which requires that the remainder of the interaction is split in two independent
processes.
This enforces a certain structure on the program. Either John will already have
to have the cake in his hands, or Mary will already have to have the bill in
the bank.
We model the second scenario below, assuming \john, \mary and \bank are
processes modelling John, Mary, and Mary's bank, and \cake and \money are the
types of two channels which give access to a slice of cake and appropriate
payment.
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tmty{y}{\money^\bot}, \tmty{x}{\cake}}$}
  \SYM{\parr}
  \UIC{$\seq[{ \cpRecv{x}{y}{\john} }]{
      \Gamma, \tmty{x}{\money^\bot \parr \cake} }$}
  \AXC{$\seq[{ \bank }]{ \Delta, \tmty{z}{\money} }$}
  \AXC{$\seq[{ \mary }]{ \Theta, \tmty{x}{\cake^\bot} }$}
  \SYM{\tens}
  \BIC{$\seq[{ \cpSend{x}{z}{\bank}{\mary} }]{
      \Delta, \tmty{x}{\money \tens \cake^\bot} }$}
  \NOM{Cut}
  \BIC{$\seq[{
      \cpCut{x}{\cpRecv{x}{y}{\john}}{\cpSend{x}{z}{\bank}{\mary}} }]{
      \Gamma, \Delta, \Theta }$}
\end{prooftree}
The resulting process reduces, as expected:
\[
  \reducesto
  {\cpCut{x}{\cpRecv{x}{y}{\john}}{\cpSend{x}{z}{\bank}{\mary}}}
  {\cpCut{y}{\bank}{\cpCut{x}{\cpSub{y}{z}{\john}}{\mary}}}
\]

\subsection{Preservation}
\label{sec:cp-preservation}
We show that term reduction preserves typing. To do so, we first prove that
structural congruence preserves typing.
\begin{restatable}[Preservation for $\equiv$]{theorem}{thmcppreservationequiv}\label{thm:cp-preservation-equiv}
  If $\seq[{ P }]{ \Gamma }$ and $\tm{P} \equiv \tm{Q}$,
  then $\seq[{ Q }]{\Gamma }$.
  \qed
\end{restatable}
\begin{proof}
  By induction on the structure of the equivalence. The cases for reflexivity,
  transitivity and congruence are trivial. The two interesting cases, for
  \cpEquivCutComm and \cpEquivCutAss1 are given in \cref{fig:cp-preservation-equiv}
  \qed
\end{proof}
\input{fig-cp-preservation-equiv}
Then, we can prove preservation.
\begin{restatable}[Preservation]{theorem}{thmcppreservation}\label{thm:cp-preservation}
  If $\seq[{ P }]{ \Gamma }$ and \reducesto{P}{Q},
  then $\seq[{ Q }]{ \Gamma }$.
  \qed
\end{restatable}
\begin{proof}
  By induction on the structure of the reduction; see \cref{fig:cp-preservation}.
  % 
  The case for \cpRedGammaCut is trivial by the induction hypothesis, and the
  case for \cpRedGammaEquiv is trivial by the induction hypothesis and
  \cref{thm:cp-preservation-equiv}.
  \qed
\end{proof}
\input{fig-cp-preservation}

\subsection{Canonical Forms and Progress}
\label{sec:cp-progress}
There are several reduction strategies for \cp, all of which use non-cut terms
as canonical forms.

The reduction strategy described by \textcite{wadler2012} matches precisely the
proof of cut-elimination for linear logic. It applies commutative conversions to
bubble actions over unrelated \textnu-binders to the \textnu-binder which
introduces the channel on which they act. It does this until it creates a
\textbeta-redex, upon which it applies \textbeta-reduction, and continues.

The reduction strategy described by \citeauthor{lindley2015semantics} creates
redexes by rewriting using the structural congruence, then applies
\cpRedAxCut1 or \textbeta-reduction. It does this until the process blocks on
one or more external communications. Then, to convert the term to canonical
form, it applies the commutative conversions to bubble one of those external
communications to the front of the term.

In this paper, we follow the latter strategy, but instead define canonical forms
as terms which are blocked on an external communication.
This allows us to exclude the commutative conversions from our reduction system,
which makes our reduction system more closely resemble that of the
\textpi-calculus.

We start out by formally defining actions, and acting.
\begin{definition}[Actions]\label{def:cp-action}
  A process \tm{P} \emph{acts on} a channel \tm{x} if it is in one of the
  following forms:
  \begin{multicols}{3}
    \begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
    \item \tm{\cpLink{x}{y}}
    \item \tm{\cpLink{y}{x}}
    \item \tm{\cpSend{x}{y}{P'}{Q'}}
    \item \tm{\cpRecv{x}{y}{P'}}
    \item \tm{\cpHalt{x}}
    \item \tm{\cpWait{x}{P'}}
    \item \tm{\cpInl{x}{P'}}
    \item \tm{\cpInr{x}{P'}}
    \item \tm{\cpCase{x}{P'}{Q'}}
    \item \tm{\cpAbsurd{x}}
    \end{itemize}
  \end{multicols}
  \noindent
  We say a process \tm{P} is an \emph{action} if it acts on some channel \tm{x}.
  \qed
\end{definition}
Furthermore, we will need the notion of an \emph{evaluation prefix}.
Intuitively, evaluation prefixes are multi-holed contexts consisting solely of
cuts. We will use evaluation prefixes in order to have a view of every
\emph{action} in a process at once.
\begin{definition}[Evaluation prefixes]\label{def:cp-evaluation-prefixes}
  We define evaluation prefixes as:
  \begin{align*}
    \tm{G}, \tm{H} := \tm{\Box} \mid \tm{\cpCut{x}{G}{H}}
  \end{align*}
  The \tm{\Box} construct represents a hole.
  \\
  We define plugging for an evaluation prefix with $n$ holes as:
  \begin{align*}
    \!\begin{array}{ll}
      \tm{\cpPlug{\Box}{R}} & = \; \tm{R} \\
      \tm{\cpPlug{\cpCut{x}{G}{H}}{R_1 \dots R_m, R_{m+1} \dots R_{n}}}
                            & = \; \tm{\cpCut{x}{\cpPlug{G}{R_1 \dots R_m}}{\cpPlug{H}{R_{m+1} \dots R_n}}}
    \end{array}
  \end{align*}
  Note that in the second case, \tm{G} is an evaluation prefix with $m$ holes,
  and \tm{H} is an evaluation prefix with $(n-m)$ holes.
  \qed
\end{definition}
Intuitively, we can say that every term of the form
\tm{\cpPlug{G}{P_1 \dots P_n}} is equivalent to some term of the form
\tm{\cpCut{x_1}{P_1}{\cpCut{x_2}{P_2}{\dots \cpCut{x_n}{P_{n-1}}{P_n} \dots}}} 
where $\tm{x_1} \dots \tm{x_{n-1}}$ are the channels bound in \tm{G}.
A similar equivalence was used by \textcite{lindley2015semantics} in their
semantics for \cp.
\begin{definition}[Maximum evaluation prefix]\label{def:cp-maximum-evaluation-prefix}
  We say that \tm{G} is an evaluation prefix of \tm{P} when there exist terms
  $\tm{P_1} \dots \tm{P_n}$ such that $\tm{P} = \tm{\cpPlug{G}{P_1 \dots P_n}}$.
  We say that \tm{G} is the maximum evaluation prefix if each \tm{P_i} is an
  action. 
  \qed
\end{definition}
\begin{restatable}{lemma}{thmcpmaximumevaluationprefix}\label{thm:cp-maximum-evaluation-prefix}
  Every term \tm{P} has a maximum evaluation prefix.
  \qed
\end{restatable}
\begin{proof}
  By induction on the structure of the term \tm{P}. 
  \qed
\end{proof}
We can now define what it means for a term to be in canonical form. Intuitively,
a process is in canonical form either when there is no top-level cut, or when it
is blocked on an external communication. We state this formally as follows:
\begin{definition}[Canonical forms]\label{def:cp-canonical-forms}
  A process \tm{P} is in canonical form if it is an action, or if it is of the
  form \tm{\cpPlug{G}{P_1 \dots P_n}}, where \tm{G} is the maximum evaluation
  prefix of \tm{P}, no \tm{P_i} is a link which acts on a bound channel, and no
  \tm{P_i} and \tm{P_j} act on the same channel.
  \qed
\end{definition}
In addition to evaluation prefixes, we also need a concept of evaluation
contexts to prove progress. Intuitively, evaluation contexts are one-holed term
contexts under which reduction can take place. For \cp, these consist solely of
cuts.
\begin{definition}[Evaluation contexts]\label{def:cp-evaluation-contexts}
  We define evaluation contexts as:
  \begin{align*}
    \tm{E} := \tm{\Box}
    \mid \tm{\cpCut{x}{E}{P}}
    \mid \tm{\cpCut{x}{P}{E}}
  \end{align*}
  We define plugging for evaluation contexts as:
  \begin{align*}
    \!\begin{array}{ll}
      \tm{\cpPlug{\Box}{R}}            
      & = \; \tm{R}
      \\
      \tm{\cpPlug{\cpCut{x}{E}{P}}{R}}
      & = \; \tm{\cpCut{x}{\cpPlug{E}{R}}{P}}
      \\
      \tm{\cpPlug{\cpCut{x}{P}{E}}{R}}
      & = \; \tm{\cpCut{x}{P}{\cpPlug{E}{R}}}
    \end{array}
  \end{align*}
  \qed
\end{definition}
Next, we prove that we can push a \textnu-binder under any evaluation context
\tm{E}, as long as \tm{E} does not use the channel name introduced by that
\textnu-binder.
\begin{restatable}{lemma}{thmcpdisplaycut}\label{thm:cp-display-cut}
  If $\seq[{ \tm{\cpCut{x}{\cpPlug{E}{P}}{Q}} }]{ \Gamma }$ and
  $\notFreeIn{x}{E}$, then $\tm{\cpCut{x}{\cpPlug{E}{P}}{Q}} \equiv
  \tm{\cpPlug{E}{\cpCut{x}{P}{Q}}}$. 
  \qed
\end{restatable}
\begin{proof}
  By induction on the structure of the evaluation context \tm{E}.
  \qed
\end{proof}
Last, we prove two lemmas relating evaluation contexts to evaluation prefixes,
showing that if we have a process acting on a channel \tm{x} under an evaluation
prefix, we can rewrite it to reveal the binder introducing \tm{x}.
Each of these lemmas deals with one of the cases for reduction.
The first allows us to reveal the binder for links.
It is an equivalence instead of an equality because it uses commutativity of
links. 
The second allows us to reveal the binder introducing the channel shared by two
actions. It is a plain equality.
Both have similar proofs.
\begin{restatable}{lemma}{thmcpprogresslink}\label{thm:cp-progress-link}
  If $\seq[{ \cpPlug{G}{P_1 \dots P_n} }]{ \Gamma }$, and some \tm{P_i} is a
  link \tm{\cpLink{x}{y}}, then either \tm{x} and \tm{y} are not bound by
  \tm{G}, or there exist \tm{E}, \tm{E'} and \tm{Q} such that
  \(
  \tm{\cpPlug{G}{P_1 \dots P_n}} \equiv
  \tm{\cpPlug{E}{\cpCut{x}{\cpPlug{E'}{\cpLink{x}{y}}}{Q}}}
  \).
  \qed
\end{restatable}
\begin{restatable}{lemma}{thmcpprogressbeta}\label{thm:cp-progress-beta}
  If $\seq[{ \cpPlug{G}{P_1 \dots P_n} }]{ \Gamma }$, and some \tm{P_i} and
  \tm{P_j} act on the same bound channel \tm{x}, then there exist \tm{E},
  \tm{E_i} and \tm{E_j} such that
  \(
  \tm{\cpPlug{G}{P_1 \dots P_n}} =
  \tm{\cpPlug{E}{\cpCut{x}{\cpPlug{E_i}{P_i}}{\cpPlug{E_j}{P_j}}}}
  \).
  \qed
\end{restatable}
\begin{proof}
  By induction on the structure of the evaluation prefix \tm{G}.
  \qed
\end{proof}
Finally, we are ready to prove progress.
\begin{restatable}[Progress]{theorem}{thmcpprogress}\label{thm:cp-progress}
  If $\seq[{ P }]{ \Gamma }$, then either $\tm{P}$ is in canonical form, or
  there exists a $\tm{P'}$ such that $\reducesto{P}{P'}$. 
  \qed
\end{restatable}
\begin{proof}
  By induction on the structure of the derivation of \seq[P]{\Gamma}.
  The only interesting case is that in which \tm{P} was constructed using a cut,
  as all other rules introduce canonical forms.
  We consider the maximum evaluation prefix \tm{G} of \tm{P}. This consists of
  $n$ cuts, but composes $n+1$ actions. Therefore, one of the following must be
  true:
  \begin{itemize}
  \item
    One of the actions is a link on a bound channel.\\
    We rewrite by \cref{thm:cp-display-cut} and \cref{thm:cp-progress-link},
    and apply \cpRedAxCut1.
  \item
    Two of the processes act on the same bound channel.\\
    We rewrite by \cref{thm:cp-display-cut} and \cref{thm:cp-progress-beta},
    and apply one of the \textbeta-rules.
  \item
    At least one process acts on a free channel.\\
    No process is a link acting on a bound channel. No two process act on the
    same bound channel. Therefore, \tm{P} is canonical.
  \end{itemize}
  \qed
\end{proof}

\subsection{Termination}
\label{sec:cp-termination}
Termination is the fact that if we iteratively apply progress to obtain a
reduction, and apply that reduction, we will eventually end up with a term in
canonical form.
Its proof is quite simple, owing to the fact that our reduction rules were all
inspired by cut reductions from classical linear logic.
\begin{restatable}[Termination]{theorem}{thmcptermination}\label{thm:cp-termination}
  If $\seq[{ P }]{ \Gamma }$, then there are no infinite $\Longrightarrow$
  reduction sequences.
  \qed
\end{restatable}
\begin{proof}
  Every reduction reduces a single cut to zero, one or two cuts.
  However, each of these cuts is \emph{smaller}, in the sense that the type of
  the channel on which the communication takes place is smaller, as each
  reduction eliminates a connective (see \cref{fig:cp-preservation}), and
  structural congruence preserves the size of the cut (see
  \cref{fig:cp-preservation-equiv}). 
  Therefore, there cannot be an infinite reduction sequence.
  \qed
\end{proof}

\section{Shared Channels and Non-Determinism}\label{sec:cpnd}
In this section, we will discuss our main contribution: an extension of \cp
which allows for races while still excluding deadlocks. 
We have seen in \cref{sec:cp-example} how \cp excludes deadlocks, but how
exactly does \cp exclude races?
Let us return to our example from \cref{sec:introduction}, to the interaction
between John, Mary and the store. 
\[
  \begin{array}{c}
    \tm{(\piPar{%
    \piSend{x}{\sliceofcake}{\piSend{x}{\nope}{\store}}
    }{%
    \piPar{\piRecv{x}{y}{\john}}{\piRecv{x}{z}{\mary}}
    })}
    \\[1ex]
    \rotatebox[origin=c]{270}{$\Longrightarrow^{\star}$}
    \\[1ex]
    \tm{(\piPar{\store}{\piPar{\piSub{\sliceofcake}{y}{\john}}{\piSub{\nope}{z}{\mary}}})}
    \quad
    \text{or}
    \quad
    \tm{(\piPar{\store}{\piPar{\piSub{\nope}{y}{\john}}{\piSub{\sliceofcake}{z}{\mary}}})}
  \end{array}
\]
Races occur when more than two processes attempt to communicate simultaneously
over the \emph{same} channel. However, the \text{Cut} rule of \cp requires that
\emph{exactly two} processes communicate over each channel:
\begin{center}
  \cpInfCut
\end{center}
We could attempt to write down a protocol for our example, stating that the store
has a pair of channels $\tm{x}, \tm{y} : \ty{\cake}$ with which it communicates
with John and Mary, taking \cake to be the type of interactions in which cake
\emph{may} be obtained, i.e.\ of both \sliceofcake and \nope, and state that the
store communicates with John \emph{and} Mary over a channel of type \ty{\cake
  \parr \cake}.
However, this \emph{only} models interactions such as the following:
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tmty{x}{\cake^\bot} }$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tmty{y}{\cake^\bot} }$}
  \SYM{\tens}
  \BIC{$\seq[{ \cpSend{y}{x}{\john}{\mary} }]{
      \Gamma, \Delta, \tmty{y}{\cake^\bot \tens \cake^\bot} }$}
  \AXC{$\seq[{ \store }]{ \Theta, \tmty{x}{\cake}, \tmty{y}{\cake} }$}
  \SYM{\parr}
  \UIC{$\seq[{ \cpRecv{y}{x}{\store} }]{
      \Theta, \tmty{y}{\cake \parr \cake} }$}
  \NOM{Cut}
  \BIC{$\seq[{ \cpCut{y}{\cpSend{y}{x}{\john}{\mary}}{\cpRecv{y}{x}{\store}} }]{
      \Gamma, \Delta, \Theta }$}
\end{prooftree}
In this interaction, John will get whatever the store decides to send on \tm{x},
and Mary will get whatever the store decides to send on \tm{y}. This means that
this interactions gives the choice of who receives what \emph{to the store}.
This is not an accurate model of our original example, where the choice of who
receives the cake is non-deterministic and depends on factors outside of any of
the participants' control!
To make matters worse, the term which models our example is entirely different
from the one we initially wrote down in the \textpi-calculus!

Modelling racy behaviour, such as that in our example, is essential
to describing the interactions that take place in realistic concurrent systems.
We would like to extend \cp to allow such races in a way which mirrors the way
in which the \textpi-calculus handles non-determinism.
Let us return to our example.
\[
  \tm{(\piPar{%
      \piSend{x}{\sliceofcake}{\piSend{x}{\nope}{\store}}
    }{%
      \piPar{\piRecv{x}{y}{\john}}{\piRecv{x}{z}{\mary}}
    })}
\]
In this interaction, we see that the channel \tm{x} is only used only as a way to
connect the various clients, John and Mary, to the store.
The \emph{real} communication, sending the slice of cake and disappointment,
takes places on the channels \tm{\sliceofcake}, \tm{\nope}, \tm{y} and \tm{z}.
Inspired by this, we add two new constructs to the term language of \cp for
sending and receiving on a \emph{shared} channel.
These actions are marked with a \tm{\star} to distinguish them from ordinary
sending and receiving. 
To group clients, we add \emph{pooling}, another form of parallel composition.
\begin{definition}[Terms]\label{def:nc-terms}
  We extend \cref{def:cp-terms} with the following constructs:
  \[\!
    \begin{aligned}
      \tm{P}, \tm{Q}, \tm{R}
           :=& \; \dots
      \\ \mid& \; \tm{\ncCnt{x}{y}{P}} &&\text{client creation}
      \\ \mid& \; \tm{\ncSrv{x}{y}{P}} &&\text{server interaction}
      \\ \mid& \; \tm{\ncPool{P}{Q}}   &&\text{parallel composition of clients, ``pooling''}
    \end{aligned}
  \]
  \qed
\end{definition}
As before, round brackets denote input, square brackets denote output.
Note that \tm{\ncCnt{x}{y}{P}}, much like \tm{\cpSend{x}{y}{P}{Q}}, is a bound
output: both client creation and server interaction bind a new name.

In \cp, we identified terms up to the commutativity and associativity of
parallel composition. In \nodcap, we add another form of parallel composition,
and therefore must extend our structural congruence:
\begin{definition}[Structural congruence]\label{def:nc-equiv}
  We extend \cref{def:cp-equiv} with the following equivalences:
  \[
    \begin{array}{llll}
      \ncEquivPoolComm
      & \tm{\ncPool{P}{Q}}
      & \equiv \;
      & \tm{\ncPool{Q}{P}}
      \\
      \ncEquivPoolAss1
      & \tm{\ncPool{P}{\ncPool{Q}{R}}}
      & \equiv \;
      & \tm{\ncPool{\ncPool{P}{Q}}{R}}
      \\
      \ncRedKappaPool1
      & \tm{\cpCut{x}{\ncPool{P}{Q}}{R}}
      & \equiv \;
      & \tm{\ncPool{P}{\cpCut{x}{Q}{R}}} \quad \text{if} \; \notFreeIn{x}{P} 
      \\
      \ncRedKappaPool2
      & \tm{\ncPool{P}{\cpCut{x}{Q}{R}}}
      & \equiv \;
      & \tm{\cpCut{x}{\ncPool{P}{Q}}{R}} \quad \text{if} \; \notFreeIn{x}{P}
    \end{array}
  \]
  \qed
\end{definition}
We do not add \ncEquivPoolAss2, as follows from \cref{def:nc-equiv}.
We add both \ncRedKappaPool1 and \ncRedKappaPool2, as \tm{\cpCut{x}{P}{Q}} and
\tm{\ncPool{P}{Q}} are two distinct constructs, and hence the rules are not 
mutually derivable. Structural congruence remains symmetric.

In any non-deadlock interaction between a server and some clients, 
there must be \emph{exactly} as many clients as there are server interactions.
Therefore, we add two new \emph{dual} types for client pools and servers, which
track how many clients or server interactions they represent.
\begin{definition}[Types]\label{def:nc-types}
  We extend \cref{def:cp-types} with the following types:
  \[\!
    \begin{aligned}
      \ty{A}, \ty{B}, \ty{C}
           :=& \; \dots
      \\ \mid& \; \ty{\take[n]{A}} &&\text{pool of} \; n \; \text{clients}
      \\ \mid& \; \ty{\give[n]{A}} &&n \; \text{server interactions}
    \end{aligned}
  \]  
  \qed
\end{definition}
The types \ty{\take[n]{A}} and \ty{\give[n]{A}} are dual.
Duality remains an involutive function.

We have to add typing rules to associate our new client and server interactions
with their types. 
The definition for environments will remain unchanged, but we will extend the
definition for the typing judgement.
To determine the new typing rules, we essentially answer the question
``What typing constructs do we need to complete the following proof?''
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tmty{y}{\cake^\bot} }$}
  \noLine\UIC{$\smash{\vdots}\vphantom{\vdash}$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tmty{y'}{\cake^\bot} }$}
  \noLine\UIC{$\smash{\vdots}\vphantom{\vdash}$}
  \AXC{$\seq[{ \store }]{ \Theta, \tmty{z}{\cake}, \tmty{z'}{\cake} }$}
  \noLine\UIC{$\smash{\vdots}\vphantom{\vdash}$}
  \noLine\TIC{$\seq[{
      \cpCut{x}{\ncPool{\ncCnt{x}{y}{\john}}{\ncCnt{x}{y'}{\mary}}}{
        \ncSrv{x}{z}{\ncSrv{x}{z'}{\store}}} }]{
      \Gamma, \Delta, \Theta }$}
\end{prooftree}
Ideally, we would still like the composition of the client pool and the server
to be a cut. This seems reasonable, as the left-hand side of the term above has
two clients, and the right-hand side has two server interactions, so \tm{x} is
used at type \ty{\take[2]{\cake^\bot}} on the left, and as \ty{\give[2]{\cake}}
on the right.
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tmty{y}{\cake^\bot} }$}
  \noLine\UIC{$\smash{\vdots}\vphantom{\vdash}$}
  \AXC{$\seq[{ \mary }]{ \Delta, \tmty{y'}{\cake^\bot} }$}
  \noLine\UIC{$\smash{\vdots}\vphantom{\vdash}$}
  \noLine\BIC{$\seq[{ \ncPool{\ncCnt{x}{y}{\john}}{\ncCnt{x}{y'}{\mary}} }]{
      \Gamma, \Delta, \tmty{x}{\take[2]{\cake^\bot}} }$}

  \AXC{$\seq[{ \store }]{ \Theta, \tmty{z}{\cake}, \tmty{z'}{\cake} }$}
  \noLine\UIC{$\smash{\vdots}\vphantom{\vdash}$}
  \noLine\UIC{$\seq[{ \ncSrv{x}{z}{\ncSrv{x}{z'}{\store}} }]{
      \Theta, \tmty{x}{\give[2]{\cake}} }$}

  \NOM{Cut}
  \BIC{$\seq[{
      \cpCut{x}{\ncPool{\ncCnt{x}{y}{\john}}{\ncCnt{x}{y'}{\mary}}}{
        \ncSrv{x}{z}{\ncSrv{x}{z'}{\store}}} }]{
      \Gamma, \Delta, \Theta }$}
\end{prooftree}
We will define the typing judgement, and then discuss servers and clients, the
two sides of the above cut, describe the rules we add, and show how they allow
us to complete our proof.
\begin{definition}[Typing judgements]\label{def:nc-typing-judgement}
  We extend \cref{def:cp-typing-judgement} with the following rules:
  {\normalfont
    \begin{center} \ncInfTake1 \ncInfGive1 \end{center}
    \begin{center} \ncInfPool  \ncInfCont  \end{center}
  }
  \qed
\end{definition}

\subsection{Clients and pooling}\label{sec:clients-and-pooling}
A client pool represents a number of independent processes, each wanting to
interact with the server. Examples of such a pool include John and Mary from our
example, customers for online stores in general, and any number of processes
which interact with a single, centralised server.

We introduce two new rules: one to construct clients, and one to pool them
together. The first rule, $(\take[1]{})$, interacts over a channel as a client.
It does this by receiving a channel \tm{y} over a \emph{shared} channel \tm{x}.
The channel \tm{y} is the channel across which the actual interaction will
eventually take place. 
The second rule, \textsc{Pool}, allows us to pool together clients. This is
implemented, as in the \textpi-calculus, using parallel composition.
\begin{center}
  \ncInfTake1
  \ncInfPool
\end{center}
Using these rules, we can derive the left-hand side of our proof by marking John
and Mary as clients, and pooling them together.
\begin{prooftree}
  \AXC{$\seq[{ \john }]{ \Gamma, \tmty{y}{\cake^\bot} }$}
  \SYM{(\take[1]{})}
  \UIC{$\seq[{ \ncCnt{x}{y}{\john} }]{ \Gamma, \tmty{z}{\take[1]{\cake^\bot}} }$}

  \AXC{$\seq[{ \mary }]{ \Delta, \tmty{y'}{\cake^\bot} }$}
  \SYM{(\take[1]{})}
  \UIC{$\seq[{ \ncCnt{x}{y'}{\mary} }]{ \Delta, \tmty{y'}{\take[1]{\cake^\bot}} }$}

  \NOM{Pool}
  \BIC{$\seq[{ \ncPool{\ncCnt{x}{y}{\john}}{\ncCnt{x}{y'}{\mary}} }]{
      \Gamma, \Delta, \tmty{x}{\take[2]{\cake^\bot}} }$}
\end{prooftree}

\subsection{Servers and contraction}\label{sec:servers-and-contraction}
Dual to a pool of clients is a server. Our interpretation of a server is a
process which offers up some number of interdependent interactions of the same
type. Examples include the store from our example, which gives out slices of
cake and disappointment, online stores in general, and any central server which
interacts with some number of client processes.

We introduce two new rules to construct servers. The first rule, $(\give[1]{})$,
marks a interaction over some channel as a server interaction. It does this by
sending a channel \tm{y} over a \emph{shared} channel \tm{x}. The channel \tm{y}
is the channel across which the actual interaction will take place.
The second rule, \textsc{Cont}, short for contraction, allows us to merge two
servers into a single server. This allows us to construct a server which has
multiple interactions of the same type, across the same shared
channel.
\begin{center}
  \ncInfGive1
  \ncInfCont
\end{center}
Using these rules, we can derive the right-hand side of our proof, by marking
each of the store's interactions as server interactions, and then contracting
them.
\begin{prooftree}
  \AXC{$\seq[{ \store }]{ \Theta, \tmty{z}{\cake}, \tmty{z'}{\cake} }$}
  \SYM{(\give[1]{})}
  \UIC{$\seq[{ \ncSrv{x'}{z'}{\store} }]{
      \Theta, \tmty{z}{\cake}, \tmty{x'}{\give[1]{\cake}} }$}
  \SYM{(\give[1]{})}
  \UIC{$\seq[{ \ncSrv{x}{z}{\ncSrv{x'}{z'}{\store}} }]{
      \Theta, \tmty{x}{\give[1]{\cake}}, \tmty{x'}{\give[1]{\cake}} }$}
  \NOM{Cont}
  \UIC{$\seq[{ \ncSrv{x}{z}{\ncSrv{x}{z'}{\store}} }]{
      \Theta, \tmty{x}{\give[2]{\cake}} }$}
\end{prooftree}
Thus, we complete the typing derivation of our example.

\subsection{Running clients and servers}
\label{sec:nc-running-clients-and-servers}
Once we have a client/server interaction, how do we run it? Ideally, we would
simply use the reduction rule closest to the one used in the \textpi-calculus. 
\[
  \reducesto
  {\tm{\cpCut{x}{\ncCnt{x}{y}{P}}{\ncSrv{x}{z}{R}}}}
  {\tm{\cpCut{y}{P}{\cpSub{y}{z}{R}}}}
\]
However, our case is complicated by the fact that in \tm{\cpCut{x}{P}{Q}} the
name restriction is an inseparable part of the composition, and therefore has to
be part of our reduction rule. 
Because of this, the above reduction can only apply in the singleton case.
If the client pool contains more than one client, such as in the term below,
then there is no way to isolate a single client together with the server,
because \tm{x} occurs in both \tm{\ncCnt{x}{y}{P}} and \tm{\ncCnt{x}{z}{Q}}.
\[
  \tm{\cpCut{x}{\ncPool{\ncCnt{x}{y}{P}}{\ncCnt{x}{z}{Q}}}{\ncSrv{x}{w}{R}}}
  \centernot\Longrightarrow
\]
Therefore, we add a second reduction rule, which handles communication between a
one client in a pool of multiple clients and a server.
\[
  \reducesto
  {\tm{\cpCut{x}{\ncPool{P}{\ncCnt{x}{y}{Q}}}{\ncSrv{x}{z}{R}}}}
  {\tm{\cpCut{x}{P}{\cpCut{y}{Q}{\cpSub{y}{z}{R}}}}}
\]
Lastly, because we have added another form of parallel composition, we add
another congruence rule, to allow for reduction inside client pools.
\begin{definition}[Term reduction]\label{def:nc-term-reduction}
  We extend \cref{def:cp-term-reduction} with the following reductions:
  \[
    \begin{array}{llll}
      \ncRedBetaStar{1}
      & \tm{\cpCut{x}{\ncCnt{x}{y}{P}}{\ncSrv{x}{z}{R}}}
      & \Longrightarrow \;
      & \tm{\cpCut{y}{P}{\cpSub{y}{z}{R}}}
      \\
      \ncRedBetaStar{n+1}
      & \tm{\cpCut{x}{\ncPool{P}{\ncCnt{x}{y}{Q}}}{\ncSrv{x}{z}{R}}}
      & \Longrightarrow \;
      & \tm{\cpCut{x}{P}{\cpCut{y}{Q}{\cpSub{y}{z}{R}}}}
    \end{array}
  \]
  \begin{prooftree}
    \AXC{\reducesto{P}{P'}}
    \SYM{\ncRedGammaPool}
    \UIC{\reducesto{\ncPool{P}{Q}}{\ncPool{P'}{Q}}}
  \end{prooftree}
  \qed
\end{definition}
The rules \ncRedBetaStar1 and \ncRedBetaStar{n+1} seem like the elimination
rules for a list-like construct. This may come as a surprise, as our client
pools are built up like binary trees, and the typing rules for both sides are
tree-like, with $(\take[1]{})$ and $(\give[1]{})$ playing the role of leaves,
and \textsc{Pool} and \textsc{Cont} merging two trees with $m$ and $n$ leaves
into one with $m+n$ leaves.
However, the server process imposes a sequential ordering on its interactions,
and it is because of this that we use list-like elimination rules.

So where does the non-determinism in \nodcap come from? Let us say we have a
term of the following form:
\[
  \tm{
    \cpCut{x}
    {\ncPool{\ncCnt{x}{y_1}{P_1}}{\dots \mid \ncCnt{x}{y_n}{P_n}}}
    {\ncSrv{x}{y}{Q}}
  }
\]
Because pooling is commutative and associative, we can rewrite this term to
bring any client in the pool to the front, before applying \ncRedBetaStar{n+1}.
Thus, like in the \textpi-calculus, the non-determinism is introduced by the
structural congruence.

Does this mean that, for an arbitrary client pool \tm{P} in
\tm{\cpCut{x}{P}{\ncSrv{x}{z}{Q}}}, every client in that pool is competing for
the server interaction on \tm{x}?
Not necessarily, as some portion of the clients can be blocked on an external
communication. For instance, in the term below, clients
$\tm{\ncCnt{x}{y_{n+1}}{P_{n+1}}} \dots \tm{\ncCnt{x}{y_m}{P_m}}$ are blocked
on a communication on the external channel \tm{a}.
\[
  \arraycolsep=0pt
  \tm{
  \begin{array}{lrl}
    \nu x.&  ((&\; \ncPool{\ncCnt{x}{y_1}{P_1}}{\dots\mid\ncCnt{x}{y_n}{P_n}}\\
          &\mid&\; \cpWait{a}{\ncPool{\ncCnt{x}{y_{n+1}}{P_{n+1}}}{\dots \mid \ncCnt{x}{y_m}{P_m}}}\;)\\
          &\mid&\; \ncSrv{x}{y_1}{\dots\ncSrv{x}{y_m}{Q}}\;)
  \end{array}}
\]
If we reduce this term, then only the clients
$\tm{\ncCnt{x}{y_1}{P_1}} \dots \tm{\ncCnt{x}{y_n}{P_n}}$
will be assigned server interactions, and we end up with the following canonical
form term. 
\[
  \arraycolsep=0pt
  \tm{
  \begin{array}{lrl}
    \nu x.&   (&\; \cpWait{a}{\ncPool{\ncCnt{x}{y_{n+1}}{P_{n+1}}}{\dots\mid\ncCnt{x}{y_m}{P_m}}}\\
          &\mid&\; \ncSrv{x}{y_{n+1}}{\dots\ncSrv{x}{y_m}{Q}}\;)
  \end{array}}
\]
This matches the reduction behaviour of the \textpi-calculus, and it fits with
out notion of computation with processes.

\subsection{Preservation}
\label{sec:nc-preservation}
Structural congruence and reduction continue to preserve typing.
We show this by extending the proofs of preservation given in
\cref{sec:cp-preservation}. 
\begin{restatable}[Preservation for $\equiv$]{theorem}{thmncpreservationequiv}\label{thm:nc-preservation-equiv}
  If $\seq[{ P }]{ \Gamma }$ and $\tm{P} \equiv \tm{Q}$,
  then $\seq[{ Q }]{\Gamma }$.
  \qed
\end{restatable}
\begin{proof}
  As \cref{thm:cp-preservation-equiv}.
  The new cases are given in \cref{fig:nc-preservation-equiv}.
  \qed
\end{proof}
\input{fig-nc-preservation-equiv}
\begin{restatable}[Preservation]{theorem}{thmncpreservation}\label{thm:nc-preservation}
  If $\seq[{ P }]{ \Gamma }$ and \reducesto{P}{Q},
  then $\seq[{ Q }]{ \Gamma }$.
  \qed
\end{restatable}
\begin{proof}
  As \cref{thm:cp-preservation}.
  The new cases are given in \cref{fig:nc-preservation}.
  \qed
\end{proof}
\input{fig-nc-preservation}

\subsection{Canonical Forms and Progress}
In this section, we extend the definition of canonical forms and the proof of
progress given in \cref{sec:cp-progress}.
First, we extend the definitions of actions with our actions for client and
server creation.
\begin{definition}[Action]\label{def:nc-action}
  We extend \cref{def:cp-action} with the following cases:
  \begin{itemize}[noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt]
  \item \tm{\ncCnt{x}{y}{P'}}
  \item \tm{\ncSrv{x}{y}{P'}}
  \end{itemize}    
  \qed
\end{definition}
It is important that we are able to reduce under pooling, as clients may need to
perform some internal computation before they are ready to communicate along
their shared channels.
Therefore, we add pooling to our definition of evaluation prefixes.
\begin{definition}[Evaluation prefixes]\label{def:nc-evaluation-prefixes}
  We extend \cref{def:cp-evaluation-prefixes} with the following constructs:
  \begin{align*}
    \tm{G}, \tm{H} := \dots \mid \tm{\ncPool{G}{H}}
  \end{align*}
  \begin{align*}
    \tm{\cpPlug{\ncPool{G}{H}}{R_1 \dots R_m, R_{m+1} \dots R_{n}}} \; =
    \tm{\ncPool{\cpPlug{G}{R_1 \dots R_m}}{\cpPlug{H}{R_{m+1} \dots R_n}}}
  \end{align*}
  Note that in the this case, \tm{G} is an evaluation prefix with $m$ holes,
  and \tm{H} is an evaluation prefix with $(n-m)$ holes.
  \\
  We also define a special case of evaluation prefixes, which we will refer to
  as \emph{pooling prefixes}. These are evaluation prefixes which consist solely
  of pooling operators and holes. 
  \qed
\end{definition}
The definition for the maximum evaluation prefix is unchanged.

There are some subtleties to our definition of canonical forms. The type system
for \cp guarantees that all links directly under a non-empty evaluation context
act on a bound channel, and that two processes acting on the same channel are
always on opposite sides of the cut which introduces that channel.
Not so for \nodcap.
For instance, the client pool from our example contains two processes acting on
the same channel, and we can add a link on two unbound shared channels to a
client pool.
\[
  \seq[{\ncPool{\ncCnt{x}{y}{\john}}{\ncCnt{x}{z}{\mary}}}]{
    \Gamma, \tmty{x}{\take[2]{\cake}}}
  \qquad
  \seq[{\ncPool{\cpLink{x}{y}}{\bank}}]{
    \Gamma, \tmty{x}{\take[2]{\money}, \tmty{y}{\give[1]{\money^\bot}}}}
\]
Neither of these examples can reduce, nor would they be considered canonical
under our old definition. We refine the definition of canonical forms to include
these examples.
\begin{definition}[Canonical forms]\label{def:nc-canonical-forms}
  A process \tm{P} is in canonical form if it is an action, or if it is of the
  form \tm{\cpPlug{G}{P_1 \dots P_n}}, where \tm{G} is the maximum evaluation
  prefix of \tm{P}, no \tm{P_i} is a link \emph{which acts on a bound channel},
  and no \tm{P_i} and \tm{P_j}, \emph{on opposite sides of at least one cut},
  act on the same channel.
  \qed
\end{definition}
We also add pooling to our definition of evaluation prefixes.
\begin{definition}[Evaluation contexts]\label{def:nc-evaluation-contexts}
  We extend \cref{def:cp-evaluation-contexts} with the following constructs:
  \begin{align*}
    \tm{E} := \dots \mid \tm{\ncPool{E}{P}} \mid \tm{\ncPool{P}{E}}
  \end{align*}
  \begin{align*}
    \tm{\cpPlug{\ncPool{E}{P}}{R}}
    & = \; \tm{\ncPool{\cpPlug{E}{R}}{P}}
    \\
    \tm{\cpPlug{\ncPool{P}{E}}{R}}
    & = \; \tm{\ncPool{P}{\cpPlug{E}{R}}}
  \end{align*}
  We also define a special case of evaluation contexts, which we will refer to
  as \emph{pooling contexts}. These are evaluation contexts which consist solely
  of pooling operators and holes.
  \qed
\end{definition}
We can still push \textnu-binders under any evaluation context \tm{E}, assuming
that \tm{E} does not use the channel name which the \textnu-binder introduces.
However, this lemma splits up into two separate lemmas in \nodcap.
One for the case in which the evaluation context is a cut, and one for the case
in which it is a pool.
\begin{restatable}{lemma}{thmncdisplaycut}\label{thm:nc-display-cut}
  If $\seq[{ \tm{\cpCut{x}{\cpPlug{E}{P}}{Q}} }]{ \Gamma }$ and
  $\notFreeIn{x}{E}$, then $\tm{\cpCut{x}{\cpPlug{E}{P}}{Q}} \equiv
  \tm{\cpPlug{E}{\cpCut{x}{P}{Q}}}$.
  \qed
\end{restatable}
\begin{restatable}{lemma}{thmncdisplaypool}\label{thm:nc-display-pool}
  If $\seq[{ \ncPool{\cpPlug{E}{P}}{Q} }]{ \Gamma }$, then
  $\tm{\ncPool{\cpPlug{E}{P}}{Q}} \equiv \tm{\cpPlug{E}{\ncPool{P}{Q}}}$. 
  \qed
\end{restatable}
\begin{proof}
  By induction on the structure of the evaluation context \tm{E}.
  \qed
\end{proof}
\Cref{thm:cp-progress-link,thm:cp-progress-beta} have to be reworded slightly,
in light of subtleties in \nodcap's canonical form.
In addition, we prove a third lemma, which is used in the case for communication
on shared channels.
\begin{restatable}{lemma}{thmncprogresslink}\label{thm:nc-progress-link}
  If $\seq[{ \cpPlug{G}{P_1 \dots P_n} }]{ \Gamma }$, and some \tm{P_i} is a
  link \tm{\cpLink{x}{y}}, then either \tm{x} and \tm{y} are not bound by
  \tm{G}, or there exist \tm{E}, \tm{E'} and \tm{Q} such that
  $\tm{\cpPlug{G}{P_1 \dots P_n}} \equiv
  \tm{\cpPlug{E}{\cpCut{x}{\cpPlug{E'}{\cpLink{x}{y}}}{Q}}}$.
  \qed
\end{restatable}
\begin{restatable}{lemma}{thmncprogressbeta}\label{thm:nc-progress-beta}
  If $\seq[{ \cpPlug{G}{P_1 \dots P_n} }]{ \Gamma }$, and some \tm{P_i} and
  \tm{P_j}, on different sides of at least one cut, act on the same bound
  channel \tm{x}, then there exist \tm{E}, \tm{E_i} and \tm{E_j} such that 
  \(
  \tm{\cpPlug{G}{P_1 \dots P_n}} =
  \tm{\cpPlug{E}{\cpCut{x}{\cpPlug{E_i}{P_i}}{\cpPlug{E_j}{P_j}}}}
  \).
  \qed
\end{restatable}
\begin{restatable}{lemma}{thmncprogressshared}\label{thm:nc-progress-shared}
  If $\seq[{ \cpPlug{G}{P_1 \dots P_n} }]{ \Gamma, \tmty{x}{\take[n]{A}} }$ and
  some $\tm{P_i}$ acts as a client on a shared channel \tm{x}, then there exists
  an $\tm{E}$ and $\tm{R_1}\dots\tm{R_{n-1}}$ such that
  \[
    \tm{\cpPlug{G}{P}} \equiv
    \tm{\cpPlug{E}{\ncPool{P_i}{\ncPool{R_1}{\ncPool{\dots}{R_{n-1}}\dots}}}},
  \]
  where $\notFreeIn{x}{E}$ and $\freeIn{x}{R_1},\dots,\freeIn{x}{R_{n-1}}$.
  \qed
\end{restatable}
\begin{proof}
  By induction on the structure of the evaluation prefix \tm{G}.
  \qed
\end{proof}
Finally, we are ready to prove progress for \nodcap.
\begin{restatable}[Progress]{theorem}{thmncprogress}\label{thm:nc-progress}
  If $\seq[{ P }]{ \Gamma }$, then either $\tm{P}$ is in canonical form, or
  there exists a $\tm{P'}$ such that $\reducesto{P}{P'}$. 
  \qed
\end{restatable}
\begin{proof}
  By induction on the structure of the derivation of \seq[P]{\Gamma}.
  The only interesting case is that in which \tm{P} was constructed using a cut,
  as all other rules introduce canonical forms.
  We consider the maximum evaluation prefix \tm{G} of \tm{P}. This consists of
  $n$ cuts, but composes $n+1$ actions. Therefore, one of the following must be
  true:
  \begin{itemize}
  \item
    One of the actions is a link on a bound channel.\\
    We rewrite by \cref{thm:nc-display-cut} and \cref{thm:nc-progress-link},
    and apply \cpRedAxCut1.
  \item
    Two of the processes act on the same bound channel. There are two cases:
    \begin{itemize}
    \item
      The channel is a shared channel with \emph{more than one client}.\\
      We rewrite by \cref{thm:nc-progress-beta,thm:nc-display-cut,thm:nc-display-pool,thm:nc-progress-shared} and apply \ncRedBetaStar{n+1}.
    \item
      Otherwise, we rewrite by \cref{thm:nc-display-cut} and
      \cref{thm:nc-progress-beta}, and apply one of the other
      \textbeta-rules---including \ncRedBetaStar{1}.
    \end{itemize}
  \item
    At least one process acts on a free channel.\\
    No process is a link acting on a bound channel. No two process act on the
    same bound channel. Therefore, \tm{P} is canonical.
  \end{itemize}
  \qed
\end{proof}

\subsection{Termination}
\label{sec:nc-termination}
Communication in \nodcap remains terminating. We show this by extending the
proof of termination given in \cref{sec:cp-termination}.
\begin{restatable}[Termination]{theorem}{thmnctermination}\label{thm:nc-termination}
  If $\seq[{ P }]{ \Gamma }$, then there are no infinite $\Longrightarrow$
  reduction sequences.
  \qed
\end{restatable}
\begin{proof}
  As \cref{thm:cp-termination}. The new cases are given in
  \cref{fig:nc-preservation,fig:nc-preservation-equiv}. 
  \qed
\end{proof}

\subsection{\nodcap and non-deterministic local choice}
\label{sec:nc-local-choice}
In \cref{sec:local-choice}, we discussed the non-deterministic local choice
operator, which is used in several extensions of \piDILL and
\cp~\parencite{atkey2016,caires2014,caires2017}.
This operator is admissible in \nodcap.
We can derive the non-deterministic choice \tm{P+Q} by constructing the
following term:
\[%
  \arraycolsep=0pt
  \tm{
  \begin{array}{lrlrl}
    \nu x.&((  & \; \ncCnt{x}{y}{\cpInl{y}{\cpHalt{y}}} \\
          &\mid& \; \ncCnt{x}{z}{\cpInr{z}{\cpHalt{z}}} \; )\\
          &\mid& \; \ncSrv{x}{y}{\ncSrv{x}{z}{}}\text{case}\;y\\
          &    & \quad
                 \begin{array}{rl}
                   \{ & \; \cpCut{w}{\cpCase{z}{\cpWait{z}{\cpHalt{w}}}{
                           \cpWait{z}{\cpHalt{w}}}}{\cpWait{w}{P}}
                   \\
                    ; & \; \cpCut{w}{\cpCase{z}{\cpWait{z}{\cpHalt{w}}}{
                           \cpWait{z}{\cpHalt{w}}}}{\cpWait{w}{Q}} \; \})
                 \end{array}
  \end{array}
  }
\]
This term is a cut between two processes.
\begin{itemize}
\item
  On the left-hand side, we have a pool of two processes,
  \tm{\ncCnt{x}{y}{\cpInl{y}{\cpHalt{y}}}} and
  \tm{\ncCnt{x}{z}{\cpInr{z}{\cpHalt{z}}}}.
  Each makes a choice:
  the first sends \tm{\text{inl}},
  and the second sends \tm{\text{inr}}. 
\item
  On the right-hand side, we have a server with both \tm{P} and \tm{Q}. This
  server has two channels on which a choice is offered, \tm{y} and \tm{z}.
  The choice on \tm{y} selects between \tm{P} and \tm{Q}.
  The choice on \tm{z} does not affect the outcome of the process at all.
  Instead, it is discarded.
\end{itemize}
When these clients and the server are put together, the choices offered by the
server will be non-deterministically lined up with the clients which make
choices, and either \tm{P} or \tm{Q} will run.

While there is a certain amount of overhead involved in this encoding, it scales
linearly in terms of the number of processes.
The reverse---encoding the non-determinism present in \nodcap using
non-deterministic local choice---scales exponentially, as with the
\textpi-calculus.

\section{Discussion and Future Work}\label{sec:discussion}
We have presented \nodcap, an extension of \cp which permits non-deterministic
communication without losing the strong connection to logic.
We have given proofs for preservation, progress, and termination for the term
reduction system of \nodcap.
We have shown that we can define non-deterministic local choice in \nodcap.
We have also presented an alternative reduction system for \cp, based on the
work by \textcite{lindley2015semantics}, which greatly reduces the number of
reduction rules needed for \cp and \nodcap, and more closely resembles reduction
in the \textpi-calculus.

\subsection{Name restriction and parallel composition}
It would be worthwhile to decouple the name restriction from the parallel
composition in \cp, as this would greatly simplify our reduction system.
We could do this, for instance, using a two-layered environment (a variant of
bracketing~\parencite{moortgat1996}) which groups sets of channels which are
interdependent. We could then decompose \textsc{Cut} into \textsc{Mix} and
\textsc{Cycle}, using different names for each end-point for clarity:
\begin{center}
  \(\ty{X}, \ty{Y}, \ty{Z} := \ty{\Gamma_1} \hsep \dots \hsep \ty{\Gamma_n}\)
  \\[1\baselineskip]
  \begin{prooftree*}
    \AXC{$\seq[{ P }]{ X }$}
    \AXC{$\seq[{ Q }]{ Y }$}
    \NOM{Mix}
    \BIC{$\seq[{ \piPar{P}{Q} }]{ X \hsep Y }$}
  \end{prooftree*}
  \begin{prooftree*}
    \AXC{$\seq[{ P }]{ \tmty{x}{A} , \Gamma \hsep \tmty{y}{A^\bot}, \Delta \hsep X }$}
    \NOM{Cycle}
    \UIC{$\seq[{ \piNew{xy}{P} }]{ \Gamma, \Delta \hsep X }$}
  \end{prooftree*}
\end{center}
A hyper-environment \ty{X} is a group of environments \(\ty{\Gamma_1} \hsep \dots
\hsep \ty{\Gamma_n}\) and guarantees that the channels in each \(\ty{\Gamma_i}\)
are used in a single, independent process.
This would allow us to add the above variant of \textsc{Mix} which does not
cause the admission of \(\ty{\bot\limp\one}\) and \(\ty{A \tens B \limp A \parr
  B}\), which in turn would allow us to unify the various constructs for
parallel composition in \cp and \nodcap, reduce the number of reduction rules
for servers and clients, and strengthen our correspondence to the
\textpi-calculus. For instance, the rules for \((\tens)\) and pooling would
become the following:
\begin{center}
  \begin{prooftree*}
    \AXC{$\seq[{ P }]{ \tmty{y}{A}, \Gamma; \tmty{x}{B}, \Delta; X }$}
    \SYM{( \tens )}
    \UIC{$\seq[{ x[y].P }]{ \tmty{x}{A \tens B}, \Gamma, \Delta; X }$}
  \end{prooftree*}
  \begin{prooftree*}
    \AXC{$\seq[{ P }]{
        \tmty{x}{\take[m]{A}}, \Gamma;
        \tmty{y}{\take[n]{A}}, \Delta; X }$}
    \NOM{Pool}
    \UIC{$\seq[{ \cpSub{x}{y}{P} }]{
        \tmty{x}{\take[m+n]{A}}, \Gamma, \Delta; X }$}
  \end{prooftree*}
\end{center}

\subsection{Cuts with leftovers}
So far, our account of non-determinism in client/server interactions only allows
interactions between equal numbers of clients and server interactions. A natural
extension of this would be to investigate if we could define a special case of
cut on a client/server interaction, such that e.g.\ the clients only consume
part of the server resources.
\begin{scprooftree}
  \AXC{$\seq[{ P }]{ \Gamma, \tmty{x}{\take[n]{A}} }$}
  \AXC{$\seq[{ Q }]{ \Delta, \tmty{x}{\give[m]{A^\bot}} }$}
  \AXC{$\ty{n} < \ty{m}$}
  \TIC{$\seq[{ \cpCut{x}{P}{Q} }]{
      \Gamma, \Delta, \tmty{x}{\give[m-n]{A^\bot}} }$}
\end{scprooftree}
Such an extension would work well together with an extension allowing clients
and servers to provide an arbitrary number of interactions.

\subsection{Recursion, variable resources, and exponentials}
Our formalism so far has only captured servers that provide for a fixed number
of clients.  More realistically, we would want to define servers that provide
for arbitrary numbers of clients.  This poses two problems: how would we define
arbitrarily-interacting stateful processes, and how would we extend the
typing discipline of \nodcap to account for them without losing its static
guarantees.

One approach to defining server processes would be to combine \nodcap with
structural recursion and corecursion, following the $\mu\text{CP}$ extension
of~\textcite{lindley2016}.  Their approach can express processes which produce
streams of \ty{A} channels. Such a process would expose a channel with the
co-recursive type \ty{\nu X. A \parr (1 \plus X)}.  Given such a process, it is
possible to produce a channel of type \ty{A \parr A \parr \cdots \parr A} for
any number of \ty{A}s, allowing us to satisfy the type \ty{\give[n]{A}} for an
arbitrary $n$.

We would also need to extend the typing discipline to capture arbitrary use of
shared channels.  One approach would be to introduce resource variables and
quantification.  Following this approach, in addition to having types
\ty{\give[n] A} and \ty{\take[n] A} for concrete $n$, we would also have types
\ty{\give[x] A} and \ty{\take[x] A} for resource variables $x$.  These variables
would be introduced by quantifiers \ty{\forall x A} and \ty{\exists x A}.
Defining terms corresponding to \ty{\forall x A}, and its relationship with
structured recursion, presents an interesting area of further work.

Our account of CP has not included the exponentials \ty{\give A} and \ty{\take
  A}. The type \ty{\take A} denotes arbitrarily many independent instances of
\ty{A}, while the type \ty{\give A} denotes a concrete (if unspecified) number
of potentially-dependent instances of \ty{A}.  Existing interpretations of
linear logic as session types have taken \ty{\take A} to denote \ty{A}-servers,
while \ty{\give A} denotes \ty{A}-clients.  However, the analogy is imperfect:
while we expect servers to provide arbitrarily many instances of their
behaviour, we also expect those instances to be interdependent.

With quantification over resource variables, we can give precise accounts of
both \cp's exponentials and idealised servers and clients. \cp exponentials
could be embedded into this framework using the definitions $\ty{\take{A}} :=
\ty{\forall{n}\take[n]{A}}$ and $\ty{\give{A}} := \ty{\exists{n}{\give[n]{A}}}$.
We would also have types that precisely matched our intuitions for server and
client behavior:
an \ty{A} server is of type \ty{\forall{n}{\give[n] A}}, as it serves an
unbounded number of requests with the requests being interdependent, while a
collection of \ty{A} clients is of type \ty{\exists{n}{\take[n] A}}, as we have
a specific number of clients with each client being independent.

\clearpage
\printbibliography

\clearpage
\appendix
\begin{subappendices}
  \renewcommand{\thesection}{\Alph{section}}%

  \section{Detailed proofs for \cp}
  \thmcpdisplaycut
  \begin{proof}
    By induction on the structure of the evaluation context \tm{E}.
    \begin{itemize}
    \item
      Case $\tm{\Box}$. By reflexivity.
    \item
      Case $\tm{\cpCut{y}{E}{R}}$.
      \[\!
        \begin{array}{ll}
          \tm{\cpCut{x}{\cpCut{y}{\cpPlug{E}{P}}{R}}{Q}} & \equiv \quad \text{by \cpEquivCutComm}\\
          \tm{\cpCut{x}{\cpCut{y}{R}{\cpPlug{E}{P}}}{Q}} & \equiv \quad \text{by \cpEquivCutAss2}\\
          \tm{\cpCut{y}{R}{\cpCut{x}{\cpPlug{E}{P}}{Q}}} & \equiv \quad \text{by \cpEquivCutComm}\\
          \tm{\cpCut{y}{\cpCut{x}{\cpPlug{E}{P}}{Q}}{R}} & \equiv \quad \text{by the induction hypothesis}\\ 
          \tm{\cpCut{y}{\cpPlug{E}{\cpCut{x}{P}{Q}}}{R}} &
        \end{array}
      \]
    \item
      Case $\tm{\cpCut{y}{R}{E}}$.
      \[\!
        \begin{array}{ll}
          \tm{\cpCut{x}{\cpCut{y}{R}{\cpPlug{E}{P}}}{Q}} & \equiv \quad \text{by \cpEquivCutAss2}\\
          \tm{\cpCut{y}{R}{\cpCut{x}{\cpPlug{E}{P}}{Q}}} & \equiv \quad \text{by the induction hypothesis}\\
          \tm{\cpCut{y}{R}{\cpPlug{E}{\cpCut{x}{P}{Q}}}}
        \end{array}
      \]
    \end{itemize}
    In each case, the side conditions for \cpEquivCutAss2, $\notFreeIn{x}{R}$ and
    $\notFreeIn{y}{Q}$, can be inferred from $\notFreeIn{x}{E}$ and the fact that
    $\tm{\cpCut{x}{\cpPlug{E}{P}}{Q}}$ is well-typed.
    \qed
  \end{proof}
  \thmcpprogresslink
  \begin{proof}
    By induction on the structure of \tm{G}.
    \begin{itemize}
    \item
      Case \tm{\Box}. Clearly \tm{x} and \tm{y} are not bound.
    \item
      Case \tm{\cpCut{z}{\cpPlug{G'}{P_1 \dots P_i \dots P_m}}{\cpPlug{G''}{P_{m+1} \dots P_n}}}.\\
      Case \tm{\cpCut{z}{\cpPlug{G'}{P_1 \dots P_m}}{\cpPlug{G''}{P_{m+1} \dots P_i \dots P_n}}}.\\
      We apply the induction hypothesis. There are two cases:
      \begin{itemize}
      \item
        If \tm{x} and \tm{y} were not bound, they remain unbound.
      \item
        If \tm{x} or \tm{y} is bound deeper in \tm{G}, we prepend one of
        \tm{\cpCut{z}{\Box}{\cpPlug{G''}{P_{m+1} \dots P_n}}},
        \tm{\cpCut{z}{\cpPlug{G'}{P_1 \dots P_m}}{\Box}},
        \tm{\ncPool{\Box}{\cpPlug{G''}{P_{m+1} \dots P_n}}}, or
        \tm{\ncPool{\cpPlug{G'}{P_1 \dots P_m}}{\Box}} to \tm{E}.
        The desired equivalence follows by congruence.
      \end{itemize}
    \item
      Case \tm{\cpCut{x}{\cpPlug{G'}{P_1 \dots P_i \dots P_m}}{\cpPlug{G''}{P_{m+1} \dots P_n}}}.\\
      Case \tm{\cpCut{y}{\cpPlug{G'}{P_1 \dots P_i \dots P_m}}{\cpPlug{G''}{P_{m+1} \dots P_n}}}.\\
      Case \tm{\cpCut{x}{\cpPlug{G'}{P_1 \dots P_m}}{\cpPlug{G''}{P_{m+1} \dots P_i \dots P_n}}}.\\
      Case \tm{\cpCut{y}{\cpPlug{G'}{P_1 \dots P_m}}{\cpPlug{G''}{P_{m+1} \dots P_i \dots P_n}}}.
      \\
      \(\arraycolsep=0pt\begin{array}[t]{llrl}
        \text{Let} & \; \tm{E}  &\; :=     &\; \tm{\Box} \; \text{and} \\
        \text{let} & \; \tm{E'} &\; :=     &\; \tm{\cpPlug{G'}{P_1 \dots P_{i-1}, \Box, P_{i+1}, \dots P_m}} \\
                   &            &\text{or} &\; \tm{\cpPlug{G''}{P_{m+1} \dots P_{i-1}, \Box, P_{i+1}, \dots P_n}}
      \end{array}\)
      \\[1ex]
      By reflexivity and \cpEquivCutComm.
    \end{itemize}
    \qed
  \end{proof}
  \thmcpprogressbeta
  \begin{proof}
    By induction on the structure of \tm{G}.
    \begin{itemize}
    \item
      Case \tm{\cpCut{x}{\cpPlug{G'}{P_1\dots P_i\dots P_m}}{\cpPlug{G''}{P_{m+1}\dots P_j\dots P_n}}}. 
      \\
      \(\arraycolsep=0pt\begin{array}[t]{lll}
        \text{Let}&\ \tm{E}  &\ :=\ \tm{\Box}, \\
                  &\ \tm{E_i}&\ :=\ \tm{\cpPlug{G'}{P_1\dots P_{i-1},\Box,P_{i+1}\dots P_m}}, \\
                  &\ \tm{E_j}&\ :=\ \tm{\cpPlug{G''}{P_{m+1}\dots P_{j-1},\Box,P_{j+1}\dots P_n}}.
      \end{array}\)
      \\[1ex]
      By reflexivity.
    \item
      Case \tm{\cpCut{x}{\cpPlug{G'}{P_1\dots P_j\dots P_m}}{\cpPlug{G''}{P_{m+1}\dots P_i\dots P_n}}}.
      \\
      As above.
    \item
      Case \tm{\cpCut{y}{\cpPlug{G'}{P_1\dots P_i\dots P_j\dots P_m}}{\cpPlug{G''}{P_{m+1}\dots P_n}}}. \\
      Case \tm{\cpCut{y}{\cpPlug{G'}{P_1\dots P_m}}{\cpPlug{G''}{P_{m+1}\dots P_i\dots P_j\dots P_n}}}.
      \\
      We obtain \tm{E}, \tm{E_1} and \tm{E_2} from the induction hypothesis and
      \cref{thm:cp-preservation-equiv}, and then prepend either
      \tm{\cpCut{y}{\Box}{\cpPlug{G''}{P_{m+1}\dots P_n}}} or
      \tm{\cpCut{y}{\cpPlug{G'}{P_1\dots P_m}}{\Box}} to \tm{E}.
      The desired equality follows by congruence.
    \end{itemize}
    The case for \tm{\Box} is excluded because $n > 1$.
    The cases in which \tm{P_i} and \tm{P_j} are on the \emph{same} side of the
    cut, but the cut binds \tm{x}, and the cases in which \tm{P_i} and \tm{P_j}
    are on different sides of the cut, but the cut binds some other channel
    \tm{y}, are excluded by the type system.
    \qed
  \end{proof}
  \thmcpprogress
  \begin{proof}
    By induction on the structure of derivation for $\seq[{ P }]{ \Gamma }$.
    The only interesting case is when the last rule of the derivation is
    \textsc{Cut}---in every other case, the typing rule constructs a term in
    which is in canonical form. 
    \\
    We consider the maximum evaluation prefix \tm{G} of \tm{P}, such that
    $\tm{P} = \tm{\cpPlug{G}{P_1 \dots P_{n+1}}}$ and each \tm{P_i} is an
    action. The prefix \tm{G} consists of $n$ cuts, and introduces $n$ channels,
    but composes $n+1$ actions. Therefore, one of the following must be true: 
    \begin{itemize}
    \item
      One of the processes is a link \tm{\cpLink{x}{y}} acting on a bound
      channel. We have: 
      \begin{gather*}
        \begin{array}{ll}
          \tm{\cpPlug{G}{P_1 \dots \cpLink{x}{y} \dots P_{n+1}}}
          & \equiv \quad \text{by \cref{thm:cp-progress-link}}
          \\
          \tm{\cpPlug{E}{\cpCut{z}{\cpPlug{E'}{\cpLink{x}{y}}}{Q}}}
          & \equiv \quad \text{by \cref{thm:cp-display-cut}}
          \\
          \tm{\cpPlug{E}{\cpPlug{E'}{\cpCut{z}{\cpLink{x}{y}}{Q}}}}
        \end{array}
      \end{gather*}
      Where $\tm{z} = \tm{x}$ or $\tm{z} = \tm{y}$.
      We then apply \cpRedAxCut1.
    \item
      Two of the processes, \tm{P_i} and \tm{P_j}, act on the same bound channel
      \tm{x}. We have:
      \begin{gather*}
        \begin{array}{ll}
          \tm{\cpPlug{G}{P_1 \dots P_i \dots P_j \dots P_{n+1}}}
          & = \quad \text{by \cref{thm:cp-progress-beta}}
          \\
          \tm{\cpPlug{G}{\cpCut{x}{\cpPlug{E_i}{P_i}}{\cpPlug{E_j}{P_j}}}}
          & \equiv \quad \text{by \cref{thm:cp-display-cut}} 
          \\
          \tm{\cpPlug{G}{\cpPlug{E_i}{\cpCut{x}{P_i}{\cpPlug{E_j}{P_j}}}}}
          & \equiv \quad \text{by \cref{thm:cp-display-cut}} 
          \\
          \tm{\cpPlug{G}{\cpPlug{E_i}{\cpPlug{E_j}{\cpCut{x}{P_i}{P_j}}}}} 
        \end{array}
      \end{gather*}
      We then apply one of the \textbeta-reduction rules.
    \item
      Otherwise (at least) one of the processes acts on an external channel.
      \\
      No process \tm{P_i} is a link.
      No two processes \tm{P_i} and \tm{P_j} act on the same channel \tm{x}.
      Therefore, \tm{P} is canonical.
    \end{itemize}
    \qed
  \end{proof}

  \section{Detailed proofs for \nodcap}
  \thmncdisplaycut
  \begin{proof}
    By induction on the structure of the evaluation context \tm{E}.
    \begin{itemize}
    \item
      Case $\tm{\Box}$, $\tm{\cpCut{y}{H}{R}}$, and $\tm{\cpCut{y}{R}{H}}$. See
      \cref{thm:cp-display-cut}.
    \item
      Case $\tm{\ncPool{E}{R}}$.
      \[\!
        \begin{array}{ll}
          \tm{\cpCut{x}{\ncPool{\cpPlug{E}{P}}{R}}{Q}}
          & \equiv \quad \text{by} \; \ncEquivPoolComm \\
          \tm{\cpCut{x}{\ncPool{R}{\cpPlug{E}{P}}}{Q}}
          & \equiv \quad \text{by} \; \ncRedKappaPool1 \\
          \tm{\ncPool{R}{\cpCut{x}{\cpPlug{E}{P}}{Q}}}
          & \equiv \quad \text{by} \; \ncEquivPoolComm \\
          \tm{\ncPool{\cpCut{x}{\cpPlug{E}{P}}{Q}}{R}}
          & \equiv \quad \text{by the induction hypothesis}\\
          \tm{\ncPool{\cpPlug{E}{\cpCut{x}{P}{Q}}}{R}}
        \end{array}
      \]
    \item
      Case $\tm{\ncPool{R}{E}}$.
      \[\!
        \begin{array}{ll}
          \tm{\cpCut{x}{\ncPool{R}{\cpPlug{E}{P}}}{Q}}
          & \equiv \quad \text{by} \; \ncRedKappaPool1 \\
          \tm{\ncPool{R}{\cpCut{x}{\cpPlug{E}{P}}{Q}}}
          & \equiv \quad \text{by the induction hypothesis}\\
          \tm{\ncPool{R}{\cpPlug{E}{\cpCut{x}{P}{Q}}}}
        \end{array}
      \]
    \end{itemize}
    In each case, the side condition for \ncRedKappaPool1, $\notFreeIn{x}{R}$,
    can be inferred from $\notFreeIn{x}{E}$, and the side conditions for the
    induction hypothesis can be inferred from \cref{thm:nc-preservation-equiv}
    and $\notFreeIn{x}{E}$.
    \qed
  \end{proof}
  \thmncdisplaypool
  \begin{proof}
    By induction on the structure of the evaluation context \tm{E}.
    \begin{itemize}
    \item
      Case $\tm{\Box}$. By reflexivity.
    \item
      Case $\tm{\cpCut{y}{E}{R}}$.
      \[\!
        \begin{array}{ll}
          \tm{\ncPool{\cpCut{y}{\cpPlug{E}{P}}{R}}{Q}}
          & \equiv \quad \text{by} \; \ncEquivPoolComm \\
          \tm{\ncPool{Q}{\cpCut{y}{\cpPlug{E}{P}}{R}}}
          & \equiv \quad \text{by} \; \ncRedKappaPool2 \\
          \tm{\cpCut{y}{\ncPool{Q}{\cpPlug{E}{P}}}{R}}
          & \equiv \quad \text{by} \; \cpEquivCutComm \\
          \tm{\cpCut{y}{\ncPool{\cpPlug{E}{P}}{Q}}{R}}
          & \equiv \quad \text{by the induction hypothesis}\\
          \tm{\cpCut{y}{\cpPlug{E}{\ncPool{P}{Q}}}{R}}
        \end{array}
      \]
    \item
      Case $\tm{\cpCut{y}{R}{E}}$.
      \[\!
        \begin{array}{ll}
          \tm{\ncPool{\cpCut{y}{R}{\cpPlug{E}{P}}}{Q}}
          & \equiv \quad \text{by} \; \ncEquivPoolComm \\
          \tm{\ncPool{Q}{\cpCut{y}{\cpPlug{E}{P}}{R}}}
          & \equiv \quad \text{by} \; \ncRedKappaPool2 \\
          \tm{\cpCut{y}{\ncPool{Q}{\cpPlug{E}{P}}}{R}}
          & \equiv \quad \text{by} \; \cpEquivCutComm \\
          \tm{\cpCut{y}{R}{\ncPool{Q}{\cpPlug{E}{P}}}}
          & \equiv \quad \text{by the induction hypothesis} \\
          \tm{\cpCut{y}{R}{\cpPlug{E}{\ncPool{P}{Q}}}}
        \end{array}
      \]
    \item
      Case $\tm{\ncPool{E}{R}}$.
      \[\!
        \begin{array}{ll}
          \tm{\ncPool{\ncPool{\cpPlug{E}{P}}{R}}{Q}}
          & \equiv \quad \text{by} \; \ncEquivPoolComm \\
          \tm{\ncPool{\ncPool{R}{\cpPlug{E}{P}}}{Q}}
          & \equiv \quad \text{by} \; \ncEquivPoolAss2 \\
          \tm{\ncPool{R}{\ncPool{\cpPlug{E}{P}}{Q}}}
          & \equiv \quad \text{by} \; \ncEquivPoolComm \\
          \tm{\ncPool{\ncPool{\cpPlug{E}{P}}{Q}}{R}}
          & \equiv \quad \text{by the induction hypothesis} \\
          \tm{\ncPool{\cpPlug{E}{\ncPool{P}{Q}}}{R}}
        \end{array}
      \]
    \item
      Case $\tm{\ncPool{R}{E}}$.
      \[\!
        \begin{array}{ll}
          \tm{\ncPool{\ncPool{R}{\cpPlug{E}{P}}}{Q}}
          & \equiv \quad \text{by} \; \ncEquivPoolAss2 \\
          \tm{\ncPool{R}{\ncPool{\cpPlug{E}{P}}{Q}}}
          & \equiv \quad \text{by the induction hypothesis} \\
          \tm{\ncPool{R}{\cpPlug{E}{\ncPool{P}{Q}}}}
        \end{array}
      \]
    \end{itemize}
    In each case, the side conditions for \ncRedKappaPool2, $\notFreeIn{y}{Q}$,
    can be inferred from the fact that
    $\tm{\ncPool{Q}{\cpCut{y}{\cpPlug{E}{P}}{R}}}$ is well-typed; the side
    conditions for \cpEquivCutAss2, $\notFreeIn{x}{R}$ and $\notFreeIn{y}{Q}$,
    can be inferred from $\notFreeIn{x}{E}$ and the fact that
    $\tm{\ncPool{\cpPlug{E}{P}}{Q}}$ is well-typed; and the side conditions for
    the induction hypothesis can be inferred from the fact that
    $\tm{\ncPool{\cpPlug{E}{P}}{Q}}$ is well-typed,
    \cref{thm:nc-preservation-equiv} and $\notFreeIn{x}{E}$.
    \qed
  \end{proof}
  \thmncprogresslink
  \begin{proof}
    As \cref{thm:cp-progress-link}. The two cases for
    \tm{\ncPool{\cpPlug{G'}{P_1 \dots P_i \dots P_m}}{\cpPlug{G''}{P_{m+1}
          \dots P_n}}} and
    \tm{\ncPool{\cpPlug{G'}{P_1 \dots P_m}}{\cpPlug{G''}{P_{m+1}
          \dots P_i \dots P_n}}} are handled exactly as the cases for cuts which
    do not bind \tm{x} or \tm{y}. 
    \qed
  \end{proof}
  \thmncprogressbeta
  \begin{proof}
    As \cref{thm:cp-progress-link}. The two cases for
    \tm{\ncPool{\cpPlug{G'}{P_1 \dots P_i \dots P_j
          \dots P_m}}{\cpPlug{G''}{P_{m+1} \dots P_n}}} and
    \tm{\ncPool{\cpPlug{G'}{P_1 \dots P_m}}{\cpPlug{G''}{P_{m+1}
          \dots P_i \dots P_j \dots P_n}}}
    are handled exactly as the cases for cuts which do not bind \tm{x}. The case
    where \tm{P_i} and \tm{P_j} are on different sides of a pool is excluded by
    the type system.
    \qed
  \end{proof}
  \thmncprogressshared
  \begin{proof}
    By induction on the structure of the evaluation context \tm{G}.
    \begin{itemize}
    \item
      Case \tm{\Box}. By reflexivity.
    \item
      Case \tm{\cpCut{y}{G}{R}}. \\
      Case \tm{\cpCut{y}{R}{G}}.
      \\
      By the induction hypothesis.
    \item
      Case \tm{\ncPool{G}{R}}. There are two cases:
      \begin{itemize}
      \item Case $\freeIn{x}{R}$.
        \begin{flalign*}
          \begin{array}{l}
            \tm{\ncPool{\cpPlug{G}{P}}{R_{n-1}}} \\
            \qquad \equiv \quad \text{by the induction hypothesis} \\ 
            \tm{\ncPool{\cpPlug{E}{
            \ncPool{P}{\ncPool{R_1}{
            \ncPool{\dots}{R_{n-2}}\dots}}}}{R_{n-1}}} \\
            \qquad \equiv \quad \text{by \cref{thm:nc-display-pool}} \\
            \tm{\cpPlug{E}{\ncPool{P}{
            \ncPool{R_1}{\ncPool{
            \dots}{\ncPool{R_{n-2}}{R_{n-1}}}\dots}}}}
          \end{array}
        \end{flalign*}
      \item Case $\notFreeIn{x}{R}$. By the induction hypothesis.
      \end{itemize}
    \item Case \tm{\ncPool{R}{G}}. There are two cases:
      \begin{itemize}
      \item Case $\freeIn{x}{R}$.
        \begin{flalign*}
          \begin{array}{ll}
            \tm{\ncPool{R_{n-1}}{\cpPlug{G}{P}}} \\
            \qquad \equiv \quad \text{by} \; \ncEquivPoolComm \\ 
            \tm{\ncPool{\cpPlug{G}{P}}{R_{n-1}}} \\
            \qquad \equiv \quad \text{by the induction hypothesis} \\ 
            \tm{\ncPool{\cpPlug{E}{
            \ncPool{P}{\ncPool{R_1}{
            \ncPool{\dots}{R_{n-2}}\dots}}}}{R_{n-1}}} \\
            \qquad \equiv \quad \text{by \cref{thm:nc-display-pool}} \\
            \tm{\cpPlug{E}{\ncPool{P}{
            \ncPool{R_1}{\ncPool{
            \dots}{\ncPool{R_{n-2}}{R_{n-1}}}\dots}}}}
          \end{array}
        \end{flalign*}
      \item Case $\notFreeIn{x}{R}$. By the induction hypothesis.
      \end{itemize}
    \end{itemize}
    \qed
  \end{proof}
  \thmncprogress
  \begin{proof}
    By induction on the structure of derivation for $\seq[{ P }]{ \Gamma }$.
    The only interesting cases are when the last rule of the derivation is
    \textsc{Cut} or \textsc{Pool}. In every other case, the typing rule
    constructs a term in which is in canonical form. 
    \\
    If the last rule in the derivation is \textsc{Cut} or \textsc{Pool}, we
    consider the maximum evaluation prefix \tm{G} of \tm{P}, such that $\tm{P} =
    \tm{\cpPlug{G}{P_1 \dots P_{m+n+1}}}$ and each \tm{P_i} is an action.
    The prefix \tm{G} consists of $m$ pools, $n$ cuts, and introduces $n$
    channels, but composes $m+n+1$ actions, at most $m+1$ of which are on the
    same side of all cuts.
    Therefore, one of the following must be true:
    \begin{itemize}
    \item
      One of the processes is a link \tm{\cpLink{x}{y}} acting on a bound
      channel. 
      \\
      We proceed as in \cref{thm:cp-progress},
      replacing \cref{thm:cp-display-cut} and \cref{thm:cp-progress-link}
      with \cref{thm:nc-display-cut} and \cref{thm:nc-progress-link}.
    \item
      Two of the processes, \tm{P_i} and \tm{P_j}, on different sides of at
      least one cut, act on the same bound channel \tm{x}. We have:
      \begin{gather*}
        \begin{array}{ll}
          \tm{\cpPlug{G}{P_1 \dots P_i \dots P_j \dots P_{m+n+1}}}
          & \equiv \quad \text{by \cref{thm:nc-progress-beta}} \\
          \tm{\cpPlug{E}{\cpCut{x}{\cpPlug{E_i}{P_i}}{\cpPlug{E_j}{P_j}}}}
        \end{array}
      \end{gather*}
      There are two cases:
      \begin{itemize}
      \item
        If \tm{x} is a shared channel, we have \tmty{x}{\take[n]{A}} with $n >
        1$ in either \tm{\cpPlug{E_i}{P_i}} or \tm{\cpPlug{E_j}{P_j}}. 
        Assume the former. 
        We can infer $\notFreeIn{x}{E_j}$.
        We have:
        \begin{gather*}
          \begin{array}{ll}
            \tm{\cpPlug{E}{\cpCut{x}{\cpPlug{E_i}{P_i}}{\cpPlug{E_j}{P_j}}}}
            & \equiv \quad \text{by \cref{thm:nc-display-pool}}
            \\
            \tm{\cpPlug{E}{\cpPlug{E_j}{\cpCut{x}{\cpPlug{E_i}{P_i}}{P_j}}}}
            & \equiv \quad \text{by \cref{thm:nc-progress-shared}}
            \\
            \multicolumn{2}{l}{
            \tm{\cpPlug{E}{\cpPlug{E_j}{\cpPlug{E_i^\prime}{\cpCut{x}{
            \ncPool{P_i}{\ncPool{R_1}{\ncPool{\dots}{R_{n-1}} \dots }}}{P_j}}}}}}
          \end{array}
        \end{gather*}
        We apply \ncRedBetaStar{n+1}.
        Similarly if \tmty{x}{\take[n]{A}} in \tm{\cpPlug{E_j}{P_j}}.
      \item
        Otherwise, we can infer $\notFreeIn{y}{E_i}$ and $\notFreeIn{y}{E_j}$.
        \\
        We proceed as in \cref{thm:cp-progress}, including \ncRedBetaStar1 in
        the \textbeta-reduction rules, and replacing \cref{thm:cp-display-cut}
        and \cref{thm:cp-progress-beta} with \cref{thm:nc-display-cut} and
        \cref{thm:nc-progress-beta}.
      \end{itemize}
    \item 
      Otherwise (at least) one of the actions acts on a free variable.
      \\
      No process \tm{P_i} is a link acting on a bound channel.
      No two processes \tm{P_i} and \tm{P_j} act on the same channel \tm{x}.
      Therefore, \tm{P} is canonical.
    \end{itemize}
    \qed
  \end{proof}
\end{subappendices}

\end{document}
%%% Local Variables:
%%% TeX-master: "main"
%%% End:
